### 	execution的用法




- 首先，我们来了解一下什么是AOP（面向切面编程），然后我们将使用一个简单的加减乘除的代码示例来演示execution的用法。

AOP（面向切面编程）是一种编程范式，它允许开发人员将横切关注点（例如日志记录、事务管理等）与业务逻辑分离。这样，我们可以在不修改核心业务代码的情况下，添加或修改这些横切关注点。在Spring框架中，AOP是通过代理实现的，代理对象在运行时拦截目标对象的方法调用，然后在执行方法前后执行横切关注点。

execution是Spring AOP中的一种切点表达式，用于匹配连接点。连接点是程序执行过程中的某个特定点，如方法调用、异常抛出等。通过execution表达式，我们可以精确地指定哪些方法需要被代理。



这个表达式匹配`com.example`包及其子包下所有类的所有方法。

希望这些示例能帮助您更好地理解Spring AOP中execution表达式的各种用法。根据您的需求，可以灵活组合这些表达式来匹配不同的切点。这将有助于您更好地将横切关注点与业务逻辑分离，从而提高代码的可维护性和可读性。


- 下面继续详细讲解Spring中execution语法

- 在Spring AOP中，execution是一个切点（Pointcut）表达式，用于匹配连接点（Join point），即程序执行过程中的某个特定点，如方法调用、异常抛出等。execution语法允许您精确地指定哪些方法需要被拦截，从而实现横切关注点（如日志记录、事务管理等）的添加或修改。

execution表达式的基本语法如下：

```sql
execution(modifiers-pattern? return-type-pattern declaring-type-pattern? name-pattern(param-pattern) throws-pattern?)
```



各部分的含义如下： 

1. modifiers-pattern：（可选）限定符模式，用于匹配方法的访问修饰符，如public、private等。可以使用`!`来表示非某个修饰符。例如，`!public`表示非public方法。 
2. return-type-pattern：返回类型模式，用于匹配方法的返回类型。例如，`int`表示返回类型为int的方法，`*`表示匹配任何返回类型。 
3. declaring-type-pattern：（可选）声明类型模式，用于匹配定义方法的类或接口。可以使用包名或类名来指定。例如，`com.example.Calculator`表示匹配`com.example.Calculator`类中定义的方法。 
4. name-pattern：方法名模式，用于匹配方法名。例如，`add`表示匹配名为add的方法，`*`表示匹配任何方法名。 
5. param-pattern：参数模式，用于匹配方法的参数类型。例如，`(int, int)`表示匹配接受两个int类型参数的方法，`(..)`表示匹配任意数量和类型的参数。 
6. throws-pattern：（可选）异常模式，用于匹配方法抛出的异常类型。例如，`throws java.lang.IllegalArgumentException`表示匹配抛出`java.lang.IllegalArgumentException`异常的方法。

现在让我们通过一个简单的加减乘除的代码示例来演示execution的用法。假设我们有一个名为`Calculator`的类，它包含四个方法：add、subtract、multiply和divide。

```java
public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }

    public int subtract(int a, int b) {
        return a - b;
    }

    public int multiply(int a, int b) {
        return a * b;
    }

    public int divide(int a, int b) {
        if (b == 0) {
            throw new IllegalArgumentException("Division by zero is not allowed");
        }
        return a / b;
    }
}
```



现在，我们想要在调用这些方法之前和之后记录日志。首先，我们需要创建一个切面（Aspect）类，该类包含前置通知（Before advice）和后置通知（After advice）方法。

```java
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class LoggingAspect {
    @Before("execution(* com.example.Calculator.*(..))")
    public void logBefore(JoinPoint joinPoint) {
        System.out.println("Before execution: " + joinPoint.getSignature().getName());
    }

    @After("execution(* com.example.Calculator.*(..))")
    public void logAfter(JoinPoint joinPoint) {
        System.out.println("After execution: " + joinPoint.getSignature().getName());
    }
}
```



在上面的示例中，我们使用了execution表达式来匹配Calculator类中所有的方法。具体来说，`execution(* com.example.Calculator.*(..))`这个表达式的含义是： 
- `* com.example.Calculator.*(..)`: 匹配任何返回类型（*），在`com.example.Calculator`类中

- 定义的任何方法（*），并允许任何参数（..）。 
- `execution(...)`: 表示这是一个execution切点表达式。

在这个切面（Aspect）中，我们定义了两个通知（Advice）方法：`logBefore`和`logAfter`。通过@Before和@After注解，我们将这两个方法分别绑定到了切点表达式，这意味着在调用Calculator类中的任何方法之前，都会先调用`logBefore`方法，并在方法执行后调用`logAfter`方法。

下面是一个简单的配置类，用于启用AOP功能：

```java
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.EnableAspectJAutoProxy;

@Configuration
@ComponentScan("com.example")
@EnableAspectJAutoProxy
public class AppConfig {
}
```



现在，让我们在主类中使用这个配置，测试一下AOP是否生效：

```java
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class Main {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        Calculator calculator = context.getBean(Calculator.class);

        int a = 10;
        int b = 2;

        System.out.println("Add: " + calculator.add(a, b));
        System.out.println("Subtract: " + calculator.subtract(a, b));
        System.out.println("Multiply: " + calculator.multiply(a, b));
        System.out.println("Divide: " + calculator.divide(a, b));

        context.close();
    }
}
```



执行这个主类，我们将看到类似以下的输出：

```yaml
Before execution: add
Add: 12
After execution: add
Before execution: subtract
Subtract: 8
After execution: subtract
Before execution: multiply
Multiply: 20
After execution: multiply
Before execution: divide
Divide: 5
After execution: divide
```



可以看到，在执行Calculator类中的每个方法之前和之后，都会输出对应的日志信息。

总结一下，我们使用Spring AOP中的execution表达式来定义切点，然后在切面中创建通知方法，实现在业务逻辑方法执行前后记录日志的功能。这样，我们可以将横切关注点（如日志记录）与核心业务逻辑分离，从而提高代码的可维护性。



- 下面将为您讲解Spring AOP中execution表达式的各种用法。在上一个回答中，我们了解了execution表达式的基本用法。现在，我们将深入讨论execution表达式的不同使用方式。我们将继续使用上文中的加减乘除的代码示例。
1. 匹配所有方法：

```java
execution(* *(..))
```



这个表达式匹配所有类的所有方法。但是，通常我们需要将范围限制在特定的包或类中。
1. 匹配特定包下的所有方法：

```java
execution(* com.example.*.*(..))
```



这个表达式匹配`com.example`包下所有类的所有方法。
1. 匹配特定类的所有方法：

```java
execution(* com.example.Calculator.*(..))
```



这个表达式匹配`com.example.Calculator`类的所有方法。
1. 匹配特定类的特定方法：

```java
execution(int com.example.Calculator.add(int, int))
```



这个表达式仅匹配`com.example.Calculator`类中的`add`方法，该方法接受两个int类型的参数，并返回一个int类型的结果。
1. 匹配特定类中返回特定类型结果的方法：

```java
execution(java.lang.String com.example.Calculator.*(..))
```



这个表达式匹配`com.example.Calculator`类中所有返回类型为`java.lang.String`的方法。
1. 匹配特定类中接受特定类型参数的方法：

```java
execution(* com.example.Calculator.*(int, int))
```



这个表达式匹配`com.example.Calculator`类中所有接受两个int类型参数的方法。
1. 匹配特定类中同时满足返回类型和参数类型的方法：

```java
execution(int com.example.Calculator.*(int, int))
```



这个表达式匹配`com.example.Calculator`类中所有返回类型为int并接受两个int类型参数的方法。
1. 匹配特定包及其子包下的所有方法：

```java
execution(* com.example..*.*(..))
```



根据您的需求，可以灵活地组合这些语法元素来创建适当的execution表达式，从而实现精确的切点匹配。这有助于将横切关注点与核心业务逻辑分离，提高代码的可维护性和可读性。

以下是一些额外的execution表达式示例，以帮助您更好地理解其语法：
1. 匹配所有public方法：

```java
execution(public * *(..))
```


1. 匹配所有非public方法：

```java
execution(!public * *(..))
```


1. 匹配所有抛出特定异常的方法：

```java
execution(* *(..) throws java.lang.IllegalArgumentException)
```


1. 匹配特定包下的所有子包（递归）：

```java
execution(* com.example..*.*(..))
```


1. 匹配接口的所有实现：

```java
execution(* com.example.MyInterface+.*(..))
```



这里，`+`表示匹配`com.example.MyInterface`及其所有实现类的方法。

当您熟悉execution表达式的语法后，可以将其与其他Spring AOP注解（如@Before、@After、@Around等）结合使用，为您的应用程序添加不同类型的横切关注点。通过这种方式，您可以在不修改核心业务逻辑的情况下添加日志记录、事务管理、性能监控等功能，从而提高代码质量和可维护性。


- 我们继续探讨Spring AOP的更多用法和高级功能。除了execution表达式之外，Spring AOP还提供了其他类型的切点表达式和注解，使您可以更灵活地定义切点和通知。
### execution切点表达式组合

在某些情况下，您可能需要组合多个切点表达式来定义更复杂的切点。Spring AOP支持使用`&&`（与）、`||`（或）和`!`（非）操作符组合切点表达式。例如：
1. 匹配特定包下的所有方法，但排除特定类：

```java
execution(* com.example..*.*(..)) && !execution(* com.example.ExcludedClass.*(..))
```


1. 匹配特定类中的两个特定方法：

```java
execution(* com.example.Calculator.add(..)) || execution(* com.example.Calculator.subtract(..))
```


### 其他类型的切点表达式

除了execution之外，Spring AOP还提供了其他切点表达式类型，例如： 
1. `within(...)`: 匹配特定类型（类或接口）内的所有连接点。例如，`within(com.example.Calculator)`匹配`com.example.Calculator`类中的所有方法。 
2. `this(...)`: 匹配特定类型的bean（实例）上的所有连接点。例如，`this(com.example.Calculator)`匹配`com.example.Calculator`类型bean上的所有方法。 
3. `target(...)`: 类似于`this(...)`，但匹配的是目标对象（即被代理对象）的类型。例如，`target(com.example.Calculator)`匹配目标类型为`com.example.Calculator`的bean上的所有方法。 
4. `args(...)`: 匹配参数类型符合给定模式的连接点。例如，`args(int, int)`匹配接受两个int类型参数的方法。 
5. `@target(...)`: 匹配具有特定注解的类上的所有连接点。例如，`@target(org.springframework.stereotype.Service)`匹配所有带有`@Service`注解的类上的方法。 
6. `@args(...)`: 匹配参数类型具有特定注解的连接点。例如，`@args(javax.validation.Valid)`匹配所有接受带有`@Valid`注解参数的方法。 
7. `@within(...)`: 匹配具有特定注解的类型内的所有连接点。例如，`@within(org.springframework.stereotype.Service)`匹配所有带有`@Service`注解的类中的方法。 
8. `@annotation(...)`: 匹配具有特定注解的方法。例如，`@annotation(org.springframework.transaction.annotation.Transactional)`匹配所有带有`@Transactional`注解的方法。

您可以根据需要使用这些切点表达式类型来定义更精确的切点，实现更灵活的AOP功能。同时，可以利用Spring AOP提供的通知类型（如@Before、@After、@AfterReturning、@AfterThrowing和@Around）来实现不同场景下的横切关注点。这些通知类型允许您在连接点（通常是方法）的特定执行阶段插入自定义代码。 

1. `@Before`: 在连接点执行之前执行通知方法。例如，您可以在此阶段执行日志记录、权限验证等操作。

```java
@Before("execution(* com.example..*.*(..))")
public void logBeforeMethod(JoinPoint joinPoint) {
    // 记录日志
}
```


1. `@After`: 在连接点执行之后执行通知方法，无论方法是否抛出异常。您可以在此阶段执行资源释放、状态恢复等操作。

```java
@After("execution(* com.example..*.*(..))")
public void cleanUpAfterMethod(JoinPoint joinPoint) {
    // 清理资源
}
```


1. `@AfterReturning`: 在连接点执行成功后（未抛出异常）执行通知方法。您可以在此阶段执行成功后的处理，如更新缓存、记录成功日志等。

```java
@AfterReturning(value = "execution(* com.example..*.*(..))", returning = "result")
public void processResult(JoinPoint joinPoint, Object result) {
    // 处理返回结果
}
```


1. `@AfterThrowing`: 在连接点抛出异常后执行通知方法。您可以在此阶段执行异常处理，如记录异常日志、发送通知等。

```java
@AfterThrowing(value = "execution(* com.example..*.*(..))", throwing = "exception")
public void handleException(JoinPoint joinPoint, Exception exception) {
    // 处理异常
}
```


1. `@Around`: 在连接点执行前后执行通知方法，允许您控制连接点的执行。您可以在此阶段实现更复杂的横切关注点，如事务管理、性能监控等。

```java
@Around("execution(* com.example..*.*(..))")
public Object wrapMethod(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
    // 在连接点执行前的操作
    Object result = proceedingJoinPoint.proceed(); // 执行连接点
    // 在连接点执行后的操作
    return result;
}
```



通过灵活地组合切点表达式和通知类型，您可以实现各种横切关注点，从而提高代码的可维护性、可读性和扩展性。Spring AOP框架为您提供了强大的工具来简化横切关注点的实现，帮助您更好地构建和管理复杂的Java应用程序。


- 在Spring AOP中，通知（Advice）是一种特殊的方法，用于在切点（Pointcut）匹配的连接点（Join point）处执行。通知可以分为五种类型，分别是：`@Before`、`@After`、`@AfterReturning`、`@AfterThrowing`和`@Around`。每种通知类型都有一些特定的属性，可以用来进一步定制通知的行为。下面我们来详细了解这些通知类型及其属性： 
1. `@Before`

`@Before`通知在连接点执行之前执行。它有一个属性：`value`，用于指定切点表达式。示例：

```java
@Before(value = "execution(* com.example..*.*(..))")
public void logBeforeMethod(JoinPoint joinPoint) {
    // 记录日志
}
```
2. `@After`

`@After`通知在连接点执行之后执行，无论方法是否抛出异常。它有一个属性：`value`，用于指定切点表达式。示例：

```java
@After(value = "execution(* com.example..*.*(..))")
public void cleanUpAfterMethod(JoinPoint joinPoint) {
    // 清理资源
}
```
3. `@AfterReturning`

`@AfterReturning`通知在连接点执行成功后（未抛出异常）执行。它有两个属性：`value`和`returning`。 
- `value`：用于指定切点表达式。 
- `returning`：用于指定返回值对象的名称，通知方法可以通过这个名称访问返回值对象。示例：

```java
@AfterReturning(value = "execution(* com.example..*.*(..))", returning = "result")
public void processResult(JoinPoint joinPoint, Object result) {
    // 处理返回结果
}
```
4. `@AfterThrowing`

`@AfterThrowing`通知在连接点抛出异常后执行。它有两个属性：`value`和`throwing`。 
- `value`：用于指定切点表达式。 
- `throwing`：用于指定异常对象的名称，通知方法可以通过这个名称访问异常对象。示例：

```java
@AfterThrowing(value = "execution(* com.example..*.*(..))", throwing = "exception")
public void handleException(JoinPoint joinPoint, Exception exception) {
    // 处理异常
}
```
5. `@Around`

`@Around`通知在连接点执行前后执行，允许您控制连接点的执行。它有一个属性：`value`，用于指定切点表达式。示例：

```java
@Around(value = "execution(* com.example..*.*(..))")
public Object wrapMethod(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
    // 在连接点执行前的操作
    Object result = proceedingJoinPoint.proceed(); // 执行连接点
    // 在连接点执行后的操作
    return result;
}
```

通过为这些通知类型设置相应的属性，您可以根据实际需求定制通知的行为。例如，您可以使用`@AfterReturning`通知来处理方法的返回值，或使用`@AfterThrowing`通知来处理方法抛出的异常。这使得Spring AOP非常灵活且强大，能够满足各种横切关注点的需求。

当然，您还可以将多个通知应用于同一个切点。例如，您可以在一个类中为同一个切点定义`@Before`和`@After`通知，以在方法执行前后执行特定操作。这种方式可以使您的代码更具模块化，方便维护和扩展。

在实际开发中，您可能需要为多个切面定义通知。为了避免代码重复，可以使用`@Pointcut`注解来定义一个可重用的切点表达式。例如：

```java
@Aspect
@Component
public class MyAspect {

    @Pointcut("execution(* com.example..*.*(..))")
    public void commonPointcut() {
        // 这个方法仅用于定义切点，不需要实现任何逻辑
    }

    @Before("commonPointcut()")
    public void logBeforeMethod(JoinPoint joinPoint) {
        // 记录日志
    }

    @After("commonPointcut()")
    public void cleanUpAfterMethod(JoinPoint joinPoint) {
        // 清理资源
    }
}
```



在这个示例中，我们定义了一个名为`commonPointcut`的切点表达式，并将其应用于`@Before`和`@After`通知。这样，当我们需要修改切点表达式时，只需在一个地方进行修改即可。

总之，Spring AOP提供了丰富的通知类型和属性，使您可以轻松地实现各种横切关注点。通过合理地使用这些通知类型和属性，您可以提高代码的可维护性、可读性和扩展性，从而更好地构建和管理复杂的Java应用程序。
