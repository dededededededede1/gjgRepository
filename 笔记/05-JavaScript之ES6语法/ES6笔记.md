
ES6 的块级作用域

```
function f1() {
  let n = 5;
  if (true) {
    let n = 10;
  }
  console.log(n); // 5
}
```

ES6 允许块级作用域的任意嵌套。块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。

let和var有区别？

（1）let是ES6新增的一个命令，用来声明局部变量，用法和var类似，但是声明的变量只在let命令所在的代码内容有效，而且有暂时性死区的约束(前面赋值报错，后面赋值不报错)；

（2）let不允许在相同作用域内，重复声明同一个变量；

（3）var声明在方法外是全局变量、声明在方法内是局部变量；

（4）记住重要的一点：var声明的变量会挂载在window上，而let和const声明的变量不会；

二、const声明一个只读的常量
const除了以下两点与let不同外，其他特性均与let相同:

1、const一旦声明变量，就必须立即初始化，不能留到以后赋值。

2、一旦声明，常量的值就不能改变。

本质：const限定的是赋值行为。

```
const a = 1;
a = 2;//报错const arr = [];
arr.push(1) //[1]
//在声明引用型数据为常量时，const保存的是变量的指针，只要保证指针不变就不会保存。下面的行为就会报错arr = [];//报错 因为是赋值行为。变量arr保存的指针改变了。
```



三、解构赋值
ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）

1、es5一次声明多个变量：

```
var a = 1,
    b = 2,
    c = 3,
```

2、es6一次声明多个变量

```
let [a,b,c] = [1,2,3];
//a = 1
//b = 2
//c = 3
```

本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。

```
let [foo, [[bar], baz]] = [1, [[2], 3]];
foo // 1
bar // 2
baz // 3let [ , , third] = ["foo", "bar", "baz"];
third // "baz"let [x, , y] = [1, 2, 3];
x // 1
y // 3let [head, ...tail] = [1, 2, 3, 4];
head // 1
tail // [2, 3, 4]let [x, y, ...z] = ['a'];
x // "a"
y // undefined
z // []
```



3、如果解构不成功，变量的值就等于undefined。

4、另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。

5、如果等号的右边不是数组，那么将会报错。

6、解构赋值允许指定默认值。

```
let [foo = true] = [];
foo // truelet [x, y = 'b'] = ['a']; // x='a', y='b'
let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'

7、注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。
```

8、如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。

9、默认值可以引用解构赋值的其他变量，但该变量必须已经声明。

对象的解构赋值

解构不仅可以用于数组，还可以用于对象：

```
let { foo, bar } = { foo: "aaa", bar: "bbb" };
foo // "aaa"
bar // "bbb"
```

（1）对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。

```
let { bar, foo } = { foo: "aaa", bar: "bbb" };
foo // "aaa"
bar // "bbb"

let { baz } = { foo: “aaa”, bar: “bbb” };baz // undefined
```


（2）如果变量名与属性名不一致，必须写成下面这样。

```
let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
baz // "aaa"let obj =;
let = obj;
f // 'hello'
l // 'world'
```



六、箭头函数
ES6 允许使用“箭头”（=>）定义函数。

如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。

```
var f = () => 5;
// 等同于
var f = function () { return 5 };var sum = (num1, num2) => num1 + num2;
// 等同于
var sum = function(num1, num2) {
  return num1 + num2;
};
```



如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。

```
var sum = (num1, num2) => { return num1 + num2; }
1.
由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。// 报错
let getTempItem = id => { id: id, name: "Temp" };// 不报错
let getTempItem = id => ({ id: id, name: "Temp" });
```



箭头函数有几个使用注意点：

函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。
不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。
不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。
不可以使用yield命令，因此箭头函数不能用作 Generator 函数。



this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。

```
// ES6
function foo() {
  setTimeout(() => {
    console.log('id:', this.id);
  }, 100);
}// ES5
function foo() {
  var _this = this;
```


setTimeout(function (), 100);
}
//转换后的 ES5 版本清楚地说明了，箭头函数里面根本没有自己的this，而是引用外层的this。
//由于箭头函数没有自己的 `this`，所以当然也就不能用 `call()`、`apply()`、`bind()`这些方法去改变



（1）var会存在变量提升现象，但是let和const则不会有这种情况

（2）暂时性死区 简称 TDZ ：只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。

```
var tmp = 123;if (true) {
  tmp = 'abc'; // ReferenceError
  let tmp;
}
```



ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。

暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。
