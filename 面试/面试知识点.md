# 商城项目：

**执行流程**

用户在进入网站后可以浏览商品的信息，同时可以将商品放进购物车中，但是不能支付。

当用户登录后可以将商品放进购物车中，同时可以下单支付等操作。

如何实现的？

注意点：

1.未登录时可以浏览，添加购物车等等

2.登录后可以添加购物车，下单，支付。

实现原理：

未登录时 **购物车的实现** ：未登录时，购物车使用cooki存放商品，cookie的key存游客的名字，游客的名字随意起。cookie的value存放商品，value是一个map，map的key是商品id，value是商品数量。

**登录后的购物车**使用redis存放。redis使用hash结构，hash有三个字段，分别是key，field和value。key是用户id，field和value是cookie中的value，使用redisTemplate中的putAll方法可以直接将map放进去。在把商品放进redis之前需要有两个判断，第一个判断：该用户购物车在没登录时，是否有商品。如果有商品，就把cookie中的商品存进redis中，此时有另一个判断，该用户在登录后是否有购物车。如果没有就创建一个购物车存放。如果有就把新放入的商品增加到购物车。

**3.

** **下订单：** 用户在点击支付后，首先会生成一个订单，订单中有订单号和其他必要的参数。当订单生成以后，商品就从库存中减掉了。当用户点击提交订单后，会进入支付流程。如果订单在一定时间没有支付，就会被取消。我们在后天写了一个定时任务，每过10秒就扫描信一次订单，把当前时间减去订单生成的时间，如果大于十分钟就把订单取消，同时把减掉的库存再加回去。

 **支付** ：支付我们单独写了个网关项目，因为其他的项目也会用到支付的代码，为了实现代码可以复用，将支付功能写成了网关。支付网中有两种支付方式，支付宝支付和吧支付。

 **支付宝支付流程** ：网关在收到支付请求时，会收到商家传过来的参数，网关把参数封装在treemap中，因为treemap是会根据字典排序的。把订单号，appid，商品总金额等参数封装完成后，将treemap转换为String形式，使用商家的私钥进行签名，这时将签名的结果再次封装到treemap中作为一个参数。此时把签名的参数通过调用支付宝接口，发起支付请求。当支付宝收到请求后首先进行验签，验签通过后，支付宝给网关返回一个付款页面，网关把页面返回给商家后，商家传到前台。用户付款成功后支付宝进行异步回调，分别回调商家的前台和网关后台。商家前台展示一个支付成功的页面以及其他的后续操作。回调网关后，网关进行验签，确认是支付宝回调后，修改网关的订单状态，然后网关再回调商家。商家收到回调后自改商家的订单状态，然后发货。这样就支付完成了。

 **微信支付流程** ：封装参数，签名，调接口返回mweburl，请求mweburl拉起支付页面，异步回调，验签，改订单，发货。。。

 **网关** ：网关中有订单表，订单表的功能是记录**那个系统访问了网关**还有**对账**功能。因为有很多系统都调用网关进行支付，所以网关也要知道是谁来调用了。订单表中有订单id，时间，订单状态，金额等等。

 **对账** ：网关会定时指定对账任务，时间自定义，一般是网站访问量小的时候对账，比如晚上1.0等。网关先调起支付宝的对账接口，获取所有订单后和自己记录的订单比较，如果不同，以支付宝的订单为准，将没记录的订单添加到网关的订单表中。然后商家也要和网关对账，此时网关的订单已经是准确的了，所以以网关的订单为准。

遇到的问题：减库存问题，网关回调失败问题，表单重复提交问题，接口幂等性问题

 **减库存** ，当库存中有一件商品，但是有两个用户都购买时，结果应该是有一个用户失败的。（如何实现？）利用数据库的行级锁，我们在减库存时，不能先查出来库存购物购，因为查出来数据后有可能已经过期了。所以直接减，不查。在update语句中直接减，同时在update的where里面加个判断条件，判断库存够不够减的。

 **回调失败** ：补偿机制。在网关中增加一个回调异常表，每当有网关回调商家失败的情况，就失记录下来。字段：时间，回调url，订单号，回调状态123。设置定时回调任务3个，分别对应123.三次回调失败后人工解决。

 **表单重复提交** ：使用token，后台生成token，发前台同时后台存进redis，redis中key是生成的token值，value随意。提交时根据生成的随机字符串（token）删掉。再次提交再删，但是之前删过，所以二次提交后删不掉了
，返回值0，提交失败。

 **接口幂等性** ：可能有网关多次回调商家的情况，回调到商家接口后先判断订单状态，如果第一次回调就修改订单状态，如果已修改说明之前已经回调过了。

## 支付购物车安全方面的问题

订单方面可以用到分布式锁来解决并发安全问题
支付的话支付宝是用到rsa非对称加密
微信的话支付是进行md5不可逆的加密

## 购物车模块实现（没有登录下，登录下）

未登录时购物车的实现：未登录时，购物车使用cooki存放商品，cookie的key存游客的名字，游客的名字随意起。cookie的value存放商品，value是一个map，map的key是商品id，value是商品数量。
登录后的购物车使用redis存放。redis使用hash结构，hash有三个字段，分别是key，field和value。key是用户id，field和value是cookie中的value，使用redisTemplate中的putAll方法可以直接将map放进去。在把商品放进redis之前需要有两个判断，第一个判断：该用户购物车在没登录时，是否有商品。如果有商品，就把cookie中的商品存进redis中，此时有另一个判断，该用户在登录后是否有购物车。如果没有就创建一个购物车存放。如果有就把新放入的商品增加到购物车。

## 商品的余量怎么同步的（减库存的问题）

直接减，利用行级锁，sql语句的更改

## 登录的方式实现

用户密码用一个md5加密，然后验证通过之后可以用jwt生成一个token，返回给前端用导航守卫进行验证

# 权限管理项目

这是一个基于角色权限的访问控制系统，不同角色的员工在登录系统后，有不同的权限。系统根据员工所拥有的的权限来显示不同的菜单和动作。（动作是什么？）动作就是url连接。

动作分为普通动作和授权动作。普通动作是加载页面所必须的url，还有就是所有员工公共的url。授权动作是管理员需要授权才可以有的动作，比如对员工的修改，增加等。只有管理员授权了这些动作，员工才有修改，增加员工的权利。

流程

员工在登陆以后，系统通过员工的id查询到员工的角色，然后根据角色查询到员工的菜单和动作列表，之后把这些菜单和动作封装到list中返回给前端。前端解析出员工的菜单和动作显示出出来。

实现

表关系

角色-用户-一对多

菜单-动作-一对多

动作-角色-多对多

角色-菜单-多对多

遇到的问题：

一个用户在地址栏中访问一个不属于他权限下的菜单时，能够访问得到。这样就造成了不安全。如何解决？设置一个拦截器，在拦截器中检查这个请求在不在用户的访问权限中。

# 单点登录：

用户访问a系统，首先进入到a的拦截器，a的拦截器判断是否有cookie，是否

有token，发现都没有。

2.系统带着自己的url跳转到SSO登录系统， SSO系统也没有登录，此时先保存传过来的url，然后跳转到用户登录页。

3.用户填写用户名、密码，SSO系统进行认证后，将登录状态写入SSO的session，浏览器（Browser）中写入SSO域下的Cookie。

4.SSO系统登录完成后会生成一个token存到redis中，key是token

的值，value随意。然后跳转到a系统，同时将token作为参数传递给a系统。

5.app系统拿到token后，从后台向发送请求，验证token是否有效。验证功能写为接口形式。

6.验证通过后，a系统将登录状态写入session并设置a网站域下的Cookie。

至此，跨域单点登录就完成了。以后我们再访问app系统时，app就是登录的。接下来，我们再看看访问app2系统时的流程。

1.用户访问b系统，首先进入到b的拦截器，b的拦截器判断是否有cookie，是否有token，发现都没有，带着自己的url跳到sso。

2.sso发现自己域下有cookie，说明之前有网站登录了，不需要重新登录认证。

3.SSO生成token存进redis，浏览器跳转到b系统，并将token作为参数传递给b。

4.b拿到token，后台访问SSO，验证token是否有效。

5.验证成功后，b将登录状态写入session，并在b网站域下写入Cookie。

在面对高并发的情况下，可以采取以下几种方法来解决问题：

1. 横向扩展：通过增加服务器的数量来分担负载。可以使用负载均衡器将请求分发到多台服务器上，从而提高系统的并发处理能力。
2. 缓存优化：对于一些频繁访问的数据，可以使用缓存来减轻数据库的压力。可以使用内存缓存如Redis或Memcached，或者使用分布式缓存如Ehcache或Hazelcast。
3. 异步处理：将一些耗时的操作转化为异步任务，减少请求的等待时间。可以使用消息队列来处理异步任务，如RabbitMQ或Kafka。
4. 数据库优化：对数据库进行性能优化，如合理设计数据库表结构、建立索引、优化SQL查询语句等，以提高数据库的并发处理能力。
5. 静态资源优化：将静态资源如图片、CSS、JS等存放到CDN（内容分发网络）上，减少服务器的压力。
6. 限流控制：通过限制请求的数量或速率来控制并发访问。可以使用工具如Guava RateLimiter或者使用框架如Sentinel来实现限流。
7. 高效算法：对于一些复杂的计算或处理逻辑，可以优化算法或采用更高效的数据结构，以提高系统的并发处理能力。
8. 异构架构：采用微服务架构或分布式架构，将系统拆分为多个独立的服务，通过服务间的异步通信来提高并发处理能力。

以上是一些常见的解决高并发问题的方法，具体的选择和实施方式需要根据具体的业务需求和系统情况来进行评估和决策

## 接口幂等性操作

### **概念**

**同一个接口，多次发出同一个请求**，**必须保证操作只执行一次。** 也就是指用户对于同一个接口发起的一次请求或者多次请求的结果是一致的，不会因为多次请求而产生不同的结果。

**前端重复提交：**例如订单接口，用户连续多次点击下单操作，导致后端收到多条请求，同一个订单可能会多次创建。

**接口超时重试：**例如支付接口，当调第三方接口时，可能由于网络等原因导致调用失败而多次调用，出现多次扣款的情况。

**消息重复消费：**例如MQ消息中间件在生产端和消费端都有重试机制，也就是说同一消息可能被重复消费的问题。

### 解决：

前端：**按钮置灰、不可点击、或者跳转到其他页面**

**场景：**当要对数据库中的一条数据进行修改时，为了避免同时被其他人修改，最好的办法就是将该数据进行加锁以防止并发；那么在高并发的情况下，会造成一个业务被执行两次的情况发生，我们可以通过悲观锁实现，也就是在sql查询语句中添加**for update**字段。

![img](https://pics2.baidu.com/feed/a8ec8a13632762d0451c7d8c0980edf1513dc658.png@f_auto?token=673d53c22debda301b04da6ed13097bb)

如果在操作过程中执行了for update，此时就会对这行记录上锁，直到整个操作完成提交事务之前，其他操作走这个查询都会进入到阻塞状态

1、Mybatis插入返回id

`insert into tbl_employee(last_name,gender,email) value(#{lastName},#{gender},#{email})   `</insert>````````

2、什么样子的数据放在redis中

3、Throldlocal

3、Syschronized

4、Dubbo原理

5、sql优化

6、vue

springboot自动装配如何实现

8、如何写一个start

    1.新建一个工程名为XXXstarter的工程

    2.引入相应的依赖

    3.业务逻辑类

    4.定义配置类（如AOP的配置）

    5.定义自动配置类创建spring.factories

写自动装配的逻辑，各种条件注入的注解，@ConditionalOnClass，@ConditionalOnMissingBean，ConditionalOnProperties等

Path 和param不能一起

9、springcloud 的常用组件

11、start 的注解

12、condition

13、servlet 中不能注入mvc的容器：因为他们不属于一个容器

14、cap是什么

15、base 原理

16、如何实现1毫秒生成1000个订单号通过时间戳+原子自增类取模

17、cas是什么

18、spring boot 设置跨域

19、两阶段和三阶段 Tcc pc1 多数情况下TCC mq不支持事务两阶段三阶段流程 egb  cep

20、nacos 服务注册发现

21、mybatis 中动态标签，一对多
多对一 实现方式，

22、sql标签顺序

23、左连接 ，右连接

24、springboot常用注解

25、java序列化对象

# Java基础

## 什么是封装

封装（Encapsulation）是面向对象编程（OOP）中的一个重要概念，指的是将数据和对数据的操作（方法）封装在一个单元中，以实现数据的隐藏和保护。

封装通过将数据和方法组合成一个单独的实体（类）来实现。在封装中，类将数据存储在私有的成员变量中，并提供公共的方法（访问器和修改器方法）来访问和操作数据。外部代码只能通过公共方法来访问数据，而无法直接访问私有成员变量。

封装的目的是将数据的实现细节隐藏起来，只向外部提供必要的接口。这样可以有效地控制数据的访问和修改，防止不合法的访问和不恰当的修改。同时，封装也提供了一种抽象机制，使得类的使用者可以更加关注类的功能，而无需关心内部的实现细节。

封装的好处包括：

- 数据隐藏：将数据封装在类的内部，防止直接访问和修改，确保数据的安全性和一致性。
- 简化调用：通过提供公共方法，使得类的使用者可以通过简单的方法调用来完成复杂的操作。
- 代码重用：封装可以将类的内部实现隐藏起来，使得类可以独立地修改和演化，而不会对外部代码产生影响，从而提高了代码的重用性和可维护性。
- 接口定义：通过封装提供的公共方法，可以为类定义清晰的接口，使得类的使用者可以更加方便地了解和使用类的功能。

封装是面向对象编程中的一项重要原则，它提供了良好的模块化和抽象机制，有助于构建可靠、可维护和可扩展的软件系统。

## 常用的包：

java.lang， java.io，java.sql ，java.util，java.net ，java.math，java.text，java.time，

## 常用类：

Object 、Integer、String、StringBuffer（线程安全）、StringBuilder、Bigdecimal、Date、File、Random、Math、System

List、set、map、ArrayList、hashMap、treeMap、Thread、ThreadLocal、

## 常见的异常类型：

1. `RuntimeException`: 运行时期异常；
2. NullPointerException：空指针异常;
3. IndexOutOfBoundsException：数组下角标越界异常;
4. ArrayIndexOutOfBoundsException（数组越界异常）：当尝试访问数组中不存在的索引时抛出。
5. ClassCastException（类转换异常）：当试图将对象强制转换为不是实例的子类时，抛出此异常;
6. ArithmeticException：当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。
7. NumberFormatException：当试图将字符串转换成数字时，失败了，抛出;
8. IllegalArgumentException：抛出的异常表明向方法传递了一个不合法或不正确的参数;
9. SQLException：数据库相关的异常;（编译时异常）

10.IOException：当发生某种IO异常时抛出;（编译时异常）

11.FileNotFoundException：打开文件失败时抛出;（编译时异常）

12.ClassNotFoundException：没有找到指定的类。（编译时异常）

## 接口和抽象类的区别

1、抽象类通过extends来继承，接口必须使用implements来实现接口

2、抽象类可以有构造方法，接口不可以

3、抽象类可以有main方法，接口不可以

4、接口可以实现多个，抽象类只能继承一个

5、接口默认使用public 抽象类可以是任意访问修饰符

## Volatile

1、是什么

2、两种特点可见 有序

3、Volatile只能保证可见，有序并不能保证原子性（不能代替锁功能）需要配合

4、在什么情况下使用，多线程

一个修饰符，用于修饰常量，

1. 可见性（Visibility）：当一个线程修改了volatile变量的值，其他线程可以立即看到最新的值，避免了数据不一致的问题。
2. 有序性（Ordering）：volatile变量的读写操作会按照声明的顺序执行，保证了操作的有序性。

然而，volatile并不能保证原子性。当多个线程同时对volatile变量进行修改时，可能会出现竞态条件的问题。如果需要保证原子性，可以使用synchronized关键字或Atomic类。

使用volatile的场景通常是在多线程环境下，一个线程写入volatile变量的值，其他线程读取该变量的值，并且对变量的修改不依赖于变量的当前值。

需要注意的是，虽然volatile可以保证可见性和有序性，但它并不能替代锁的功能。在需要保证一系列操作的原子性时，仍然需要使用锁来进行同步控制。

## ThreadLocal

1、定义

2、应用场景

3、介绍 threadlocalmap key为ThreadLocal实例 value为线程变量的副本，

4、介绍弱引用和强引用

ThreadLocal是一个线程局部变量，它为每个线程提供了一个独立的变量副本。每个线程都可以独立地访问和修改自己的副本，而不会影响其他线程的副本。ThreadLocal通常用于在多线程环境下实现线程安全的数据共享，每个线程都可以访问自己的数据副本而无需加锁。

Key(ThreadLocal)势必会被GC回收，这样就会导致 ThreadLocalMap 中 key 为null， 而 value 还存在着强引用，只有 Thead 线程退出以后, value 的强引用链条才会断掉

当 ThreadLocalMap 的
key 为弱引用回收 ThreadLocal 时，由于
ThreadLocalMap 持有 ThreadLocal 的弱引用，即使没有手动删除，ThreadLocal 也会被回收。当key为null，在下一次ThreadLocalMap调用set(),get()，remove()方法的时候会被清除value值。

## Dubbo原理

生产者将对应的接口和ip和端口放到zook

消费者先从zook中将对应的生产者存放的IP和端口取出，通过动态代理调用invoke方法 生成一个invoker对象 在方法中将接口名，方法名，方法参数封装为一个对象进行序列化将通过netty通信将其发送给生产者，生产者获取到对应数据将其反序列化，获得对应的接口名，方法名，方法参数通过接口名在容器中getbean 获取接口实例，根据对应的方法名和方法参数调用具体方法进行返回。

## Syschronized

可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，并且还可以保证共享变量的内存可见性。

普通方法：锁是当前对象的实例

静态同步方法：锁是当前类的class实例

同步方法块：锁是括号里面的对象

## Syschronized和volatile的区别

1、volatile本质，synchronized 锁定当前变量

2、v 支持一个级别，s 支持三个级别

3、v可见，有序 s 可见，有序，原子

4、v 不会阻塞，s 会

5、v 不会被编译器优化 s会

![](file:///C:/Users/90504/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg)

## Syschronized和Lock的区别

1、sysch 关键字 lock锁对象

2、sysch 能完成的 lock都能完成

3、sysch 少量代码效率高，lock 大量代码效率高

4、sysch 会主动释放锁，lock不会

5、sysch 不可以判断锁是否获取，lock可以

6、sysch不会出现死锁，lock会

![](file:///C:/Users/90504/AppData/Local/Temp/msohtmlclip1/01/clip_image004.jpg)

## Sql优化

MySQL优化：

数据库优化和sql语句优化，程序员进行sql语句优化，主要是对查询语句进行优化

哪些需要建索引：

哪些字段不可以建索引：（为啥不能建：建立了也不用它，增删改的时候会进行索引的维护，还浪费空间）不经常用的字段、表数量很少的时候；

建索引的优势：

哪些操作索引会失效：

用explain测一下

1. SQL 语句尽量用大写的。
2. 使用表的别名。
3. SELECT 子句中避免使用 * 。
4. 根据需要用UNION ALL 替换UNION。
5. 用>=替代>。
6. 用EXISTS 替换DISTINCT。
7. 用Where 子句替换HAVING 子句。
8. 用EXISTS 替代 IN、用 NOTEXISTS 替代 NOTIN。
9. 多使用commit。

Sql优化包括数据库优化和sql语句优化，我们做的主要是sql优化，包括一些增删改查，一般是对查询进行优化。

首先就是建立合适的索引：

    什么样的字段适合建立索引：

1、经常用于where查询条件的字段

2、经常用于连接表的字段

3、经常用于排序的字段

4、经常用于分组的字段

5、数据具有高度唯一性的字段

    什么样的字段不适合建立索引，为什么不适合建立：

1、数据重复率较高的字段

2、增删改较为频繁的表

3、查询数据量很小的表

4、关联性很强的表

5、不经常用的字段建立了也不用它，增删改的时候会进行索引的维护，还浪费空间

建索引的优势：

1、能够更加快速对数据进行检索

2、减少IO操作

3、提高数据的完整性：

哪些操作索引会失效：

1、如果在查询时使用了复合索引，要遵循最左前缀，也就是查询从索引的最左列开始，不能跳过索引中的列

2、不要在where子句后面进行null的判断和不等号的使用，导致引擎放弃使用索引

3、不在where后面做函数运算

4、如果使用模糊查询前面使用%会是索引失效

5、语句中有隐式转换；

6、表中的数据较小，或者需要查询大部分的数据。数据库自动选择最优，可能不走索引；

Sql具体优化：

用explain测一下

Sql语句执行顺序

```
from >>> on >>> join>>> where >>> group by >>> avg,sum... >>>>>> having >>> select >>> distinct >>>order by>>> limit
```

## 什么是CAS

CAS是一种乐观锁机制，也被称为无锁机制。全称: Compare-And-Swap。它是并发编程中的一种原子操作，通常用于多线程环境下实现同步和线程安全。CAS操作通过比较内存中的值与期望值是否相等来确定是否执行交换操作。如果相等，则执行交换操作，否则就会失败（返回true和false）可以通过CAS实现自旋的操作。由于CAS是一种无锁机制，因此它避免了使用传统锁所带来的性能开销和死锁问题，提高了程序的并发性能。

CAS会出现ABA问题

## cap是什么

①一致性：对于客户端的每次读操作，要么读到的是最新的数据，要么读取失败。换句话说，一致性是站在分布式系统的角度，对访问本系统的客户端的一种承诺：要么我给您返回一个错误，要么我给你返回绝对一致的最新数据，不难看出，其强调的是数据正确。

②可用性：任何客户端的请求都能得到响应数据，不会出现响应错误。换句话说，可用性是站在分布式系统的角度，对访问本系统的客户的另一种承诺：我一定会给您返回数据，不会给你返回错误，但不保证数据最新，强调的是不出错。

③分区容错性：由于分布式系统通过网络进行通信，网络是不可靠的。当任意数量的消息丢失或延迟到达时，系统仍会继续提供服务，不会挂掉。换句话说，分区容忍性是站在分布式系统的角度，对访问本系统的客户端的再一种承诺：我会一直运行，不管我的内部出现何种数据同步问题，强调的是不挂掉。

Ap：放弃一致性，保持可用性
用于访问量大的时候

Cp：面对网络分区的时候保持一致性，放弃可用性

## Base理论

BASE理论总共包括三项，分别是“Basically
Available(基本可用）、Soft state(软状态）和Eventually consistent(最终一致性）”。

1、Basically Available(基本可用）

本人理解，**基本可用就是满足强一致性**，也就是CAP中的C（Consistent），同时依然要保持着P（Partition Torlerance）,那么就需要牺牲A（Available）。

这里说的基本可用不是完全不可用，只是在分布式系统出现了故障的时候，暂时部分访问请求不能响应，比如，分布式系统的节点之间的网络发生中断或延时，此时系统正插入一条数据，虽然主体已经完成写入，但副本因为网络暂时不通，则无法复制，但因为Basically Available是要求强一致性，所以必须要等所有副本都写入该条数据后可写入成功，但不能永远等待，会有一个时间周期，超过这个周期，那么就反馈一个失败的信息，如果成功了，但响应时间也比较长，正常情况下300毫秒返回，实际是2秒返回，导致响应时间上的损失。

一般对数据一致性要求很高的交易类系统必须是“Basically Available”状态。

2、Soft state (软状态）

就是指写入数据库的数据可以有中间状态，即使数据副本没有完全同步也可以对外提供数据的访问，只是数据不一致罢了。

软状态因为对分布式系统的数据一致性要求不高，因此，能够提供很高的可用性，也就是满足高可用（Available），降低了一致性（Consistent）。

一般比如新闻的网友评论、博客、论坛等系统比较适合该状态。

3、Eventually
consistent(最终一致性）

主要强调分布式系统中数据的各个副本会在某一时间达到一致的状态，最终一致性和强一致性不同，强一致性是必须要保证所有副本完全一致后才可以对外提供查询响应，最终一致性是在未达到各副本一致的时候就可以提供对外的查询访问，可用性相比强一致性高出很多，但最终会保证各副本一致。

## java序列化对象

Serializable    ObjectOutputStream类；writeObject（需要序列化的对象）

hessian

json  new ObjectMapper   writeValueAsBytes()

Fastjson
toJSONString

若对象中有一个属性不需要序列化 通过transient 修饰

## mybatis中动态sql要用到什么标签

MyBatis中使用动态SQL可以根据条件来生成不同的SQL语句，提供了以下几个标签用于实现动态SQL：

if：用于条件判断，根据条件动态生成SQL语句片段。示例：

choose/when/otherwise：类似于Java中的switch语句，根据不同的条件选择不同的分支。示例：

foreach：用于遍历集合或数组，生成重复的SQL语句片段。示例：

trim/where/set：用于对SQL语句进行修剪，去除不必要的关键字或条件。示例：

这些动态SQL标签可以根据业务需求和条件灵活地生成不同的SQL语句，避免了硬编码和重复代码的问题，提高了SQL语句的可读性和维护性。可以根据具体的需求选择合适的标签来构建动态SQL语句。

#### 多对一：

再对应的emp类中加dept的类

```
<association property="dept" javaType="com.bean.Dept">
	<id column="deptno" property="deptno"/>
	<result column="dname" property="dname"/>
	<result column="loc" property="difang"/>
</association>
```

#### 一对多：

再对应的dept类中加一个list `<emp>`

```
`<collection property="emps" ofType="emp">`**
    `<id column="empno" property="yuangongbianhao"/>`
    **`<result column="ename" property="xingming"/>`**
    `	<result column="job" property="zhiwei"/>`
    `<result column="mgr" property="mgr"/>`**
    `<result column="hiredate" property="hiredate"/>`
 **`<result column="sal" property="sal"/>`**
   `<result column="comm" property="comm"/>`
    `<result column="deptno" property="deptno"/>`
</collection>
```

## 异常的处理方式 注解配置异常

1、通过try-catch -finally

2、Throw（抛出异常的关键字，用于抛出指定的异常并指定异常的类型） 和throws（用于方法声明处，表明此方法可能抛出什么样的异常）

3、自定义异常类
通过继承异常类Exception 或RunTimeException实现对应的构造方法，和对应的异常处理的方法

4、配置全局异常处理 **核心：** **@RestControllerAdvice+@ExceptionHandler**

使用try-catch块进行异常处理：

o    在可能会引发异常的代码块中，使用try块包裹，并在catch块中捕获和处理异常。catch块可以根据异常类型来捕获特定的异常，并采取相应的处理逻辑。

o    通常，可以在catch块中打印异常信息、记录日志、进行错误恢复操作或抛出新的异常，以便更好地处理异常情况。

o    示例代码如下：

```
javaCopy codetry {

  // 可能引发异常的代码

} catch (ExceptionType1 e1) {

  // 处理 ExceptionType1 类型的异常

} catch (ExceptionType2 e2) {

  // 处理 ExceptionType2 类型的异常

} finally {

  // 可选的 finally 块，用于执行清理操作

}
```

使用throws关键字声明方法可能抛出的异常：

o    在方法声明中使用throws关键字，列出方法可能抛出的异常类型。这样做的目的是将异常的处理责任交给方法的调用者，在调用方法的地方进行异常处理。

o    当方法中发生异常时，异常将被传播到方法的调用者，调用者可以选择使用try-catch块捕获并处理异常，或者继续向上一级调用者传播异常。

o    示例代码如下：

```
javaCopy codepublic void someMethod() throws ExceptionType1, ExceptionType2 {

  // 可能抛出 ExceptionType1 或 ExceptionType2 类型的异常

}
```

上述代码中的 `<span lang="EN-US">@ControllerAdvice</span>`注解用于定义全局异常处理类，`<span lang="EN-US">@ExceptionHandler</span>`注解用于定义具体的异常处理方法。根据不同的异常类型，选择相应的处理逻辑，并返回适当的响应给客户端。

通过使用try-catch块和throws关键字，以及注解配置异常处理，可以灵活地处理不同类型的异常，并提供适当的异常处理策略。具体使用哪种方式取决于开发者对异常的处理需求和场景的不同。

## Spring、Spring MVC、Spring Boot和Spring Cloud 四个的区别

这四个名词（Spring、SpringMVC、Spring Boot和Spring Cloud）都是指的是Spring框架及其子项目。让我们来看看它们的主要区别：

Spring: 这是一个开源的Java/JavaEE全栈轻量级应用框架，提供了一系列的服务，如依赖注入（DI）、面向切面编程（AOP）、事务管理等等，让开发者可以更加容易地开发出松耦合的应用程序。

Spring MVC: Spring MVC是Spring框架的一部分，是一个提供了**模型-视图-控制器**（MVC）架构和可以用来创建可扩展性强的多层Java Web应用的框架。它处理了诸如**请求映射、数据绑定**等等的基础工作。

Spring Boot: Spring Boot是Spring的一个子项目，目的在于简化Spring应用的初始搭建以及开发过程。Spring Boot通过提供各种默认配置来使项目更加快速和便捷的进行，它也包括了一个运行器，可以直接运行应用，无需额外的服务器，包括自动装配，起步依赖，内置tomcat容器。

Spring Cloud: Spring Cloud是一套完整的微服务解决方案的框架，包含了微服务通信、配置中心、服务发现、断路器、路由、负载均衡、网关等组件。它基于Spring Boot构建，使得开发分布式系统变得简单。

总结一下，Spring框架提供了创建企业级Java应用程序的基础架构。Spring MVC是这个框架的一个组成部分，专门用于构建Web应用程序。Spring Boot则简化了使用Spring进行开发的过程，使开发者更容易创建Spring应用程序。Spring Cloud则是在Spring Boot的基础上，为开发微服务架构提供了一整套解决方案。

## 说说List,Set,Map三者的区别？

**List(对付顺序的好帮手)：

**List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的 对象

**Set(注重独一无二的性质): **不允许重复的集合。不会有多个元素引用相同的对象。Hashset 只能有一个空值，

**Map(用Key来搜索的专家): **使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相 同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。

HashMap 的key可有一个为空

当长时间等待未相应则告诉其他的回滚

## Java 中 IO 流分为几种?

按照流的流向分，可以分为输入流和输出流；

按照操作单元划分，可以划分为字节流和字符流；

按照流的角色划分为节点流和处理流。

## 聚簇索引和非聚簇索引

聚簇索引就是按照每张表的主键构造一颗B+树，它将数据存储与索引放到了一块,找到索引也就找到了数据，聚簇索引的主键具有唯一性 每张表只能拥有一个聚簇索引（因为聚簇索引决定了表的物理排列顺序,一个表只能有一个物理排列顺序,所以一个表只能建一个聚集索引）

非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，当通过索引访问数据，在内存中直接搜索索引，然后通过索引找到磁盘相应数据

## 在 JavaScript 中，你可以使用以下方法来获取表单元素的值：

**1. 通过 ID 获取表单元素的值：**

var value = document.getElementById("elementId").value; 在这个示例中，"elementId" 是你要获取值的表单元素的 ID，通过
`document.getElementById`  方法获取元素，然后使用  `.value`  属性获取其值。

2. 通过表单元素的 name 属性获取值：

var value =document.getElementsByName("elementName")[0].value;

   在这个示例中，"elementName" 是你要获取值的表单元素的 name 属性，通过
`document.getElementsByName`  方法获取元素的集合，然后使用索引  `[0]`  获取第一个元素，并使用  `.value`
属性获取其值

**3. 通过表单元素的类名获取值（如果有）：**

var value = document.getElementsByClassName("elementClass")[0].value;

   在这个示例中，"elementClass" 是你要获取值的表单元素的类名，通过  `document.getElementsByClassName`  方法获取元素的集合，然后使用索引  `[0]`  获取第一个元素，并使用  `.value`  属性获取其值。

## 在 jQuery中，你可以使用不同的方法来获取表单元素的值，具体取决于你想要获取的元素类型和选择器。

**1. 通过ID获取表单元素的值：**

var value = $("#elementId").val();

在这个示例中， `#elementId` 是你要选择的表单元素的ID， `.val()` 方法用于获取该元素的值，.attr() 为存值

**2. 通过表单元素的name属性获取值：**

var value = $("[name='elementName']").val();

在这个示例中， `[name='elementName']` 是你要选择的表单元素的name属性， `.val()` 方法用于获取该元素的值。

**3. 通过表单元素的类名获取值：**

var value = $(".elementClass").val();

在这个示例中， `.elementClass` 是你要选择的表单元素的类名， `.val()` 方法用于获取该元素的值。

## JDK常用命令

1、jar——多用途的存档及压缩工具，是个java应用程序，可将多个文件合并为单个JAR归档文件。

 2、java——用来执行class文件的，关联控制台。

 3、javac——java编程语言编译器。将类和接口的定义编译成字节代码的class文件。

 4、javaw——用来执行class文件的，但可以将dos窗口隐藏掉，不关联控制台。

 5、javap——Java类文件解析器，其输出取决于所用选项

JDK 常用命令确实包括了一些 Java 常用命令，但还包括其他一些用于开发和调试的命令。以下是一些常用的 JDK 命令：

1. `javac`：编译 Java 程序。
2. `java`：运行 Java 程序。
3. `jar`：创建和管理 JAR 文件。
4. `javadoc`：生成 API 文档。
5. `jshell`：Java 9 引入的交互式 Shell，用于快速测试和验证代码。
6. `jdeps`：分析类或 JAR 文件的依赖关系。
7. `jlink`：创建自定义运行时镜像。
8. `jimage`：操作和查看镜像文件。

## 什么是反射

所谓反射是指：在运行状态下，对于任意一个类都能够知道这个类所有的属性和方法，并且对任意一个对象，都能够调用他的任意一个方法。

反射的执行流程：获取class对象(字节码对象)-> 获取构造方法getConstruct-> new Instance 获取对象示例-> 获取该类的属性和方法

**获取class对象的三种方式：**

 **1、** **调用对象的getclass（）方法**

 **2、** **通过类名点class**

 **3、** **通过Class.forName(“类的全路径名”) 最为常用*

## JDK1.8的新特性

一 StreamApi--jdk1.8增加了stream特性，主要是基于fork-join框架构建，而且你可以通过parallel()与sequential()在并行流与顺序流之间进行切换。
二 Hashmap性能优化：
 1最重要的一点是底层结构不一样，1.7是数组+链表，1.8则是数组+链表+红黑树结构;
 2.插入键值对的put方法的区别，1.8中会将节点插入到链表尾部，而1.7中是采用头插
3.jdk1.7中的hash函数对哈希值的计算直接使用key的hashCode值，而1.8中则是采用key的hashCode异或上key的hashCode进行无符号右移16位的结果，避免了只靠低位数据来计算哈希时导致的冲突，计算结果由高低位结合决定，使元素分布更均匀

三、增加了Lambda表达式

四、JVM 的永久代换成元数据

日期/时间 API (Date/Time API)：Java 8引入了新的日期和时间API，解决了旧版日期/时间类库的一些问题。

## 如果一个查询功能较慢可以在哪方面入手

（1）代码优化
代码优化分析相关的代码，找出相应的瓶颈，再来考虑具体的优化策略。减少循环次数循环是消耗时间的操作，应该尽可能减少循环次数。使用缓存：缓存可以避免重复计算，提高性能。
（2）数据库层面优化
sql语句的优化加入适合的索引，查询尽量大写，少使用*，使用where代替having，exist代替in，not exist代替not in，多使用commit
（3）数据库表的优化
还可以进行分库分表（水平分，垂直分）

# spring

## Ioc控制反转

定义

使用了单例和工厂两种设计模式 （scope属性prototype）

Spring默认为非懒加载 lazyinit  true或false

单例缺点 (成员变量存储数据会产生多线程问题)  打印this判断单例，断点

实现原理反射

注入方式 （四种）

两种注解注入区别 resouse 默认名称

四个扫描

是一种编程思想。传统程序是我们使用对象的时候直接new出来，而使用ioc后，对象全部被放进了ioc容器中。使用对象的时候直接从容器中获取，spring在初始化的时候，容器里的对象就已经被创建出来了()，默认是单例的。实现原理是反射，

## Aop

1、定义（面向切面编程）

2、一般用于：记录日志，事务管理，权限管理

3、采用动态代理实现

4、两种动态代理 JDK动态代理，CGLIB

5、优点：降低耦合度，减少代码重复，利于扩展和维护

6、关键词：连接点，切点，通知，切面

7、Spring事务两种 rollbackfor

8、Spring事务传播机制 REQUIRED

9、Spring事务的四种特性

Aop面向切面编程，是面向对象的一种补充。用于将那些与业务没有关系并且对多个对象产生影响的公共行为和逻辑进行抽取出来，封装的一个可重用的模块中，这个模块称为切面。主要的应用包括，像是日志，事务管理，权限管理等都是交叉业务逻辑。

Aop时使用动态代理实现的，动态代理有两种方式，jdk动态代理，CGLIB

JDK动态代理：只提供接口代理，不支持代理类，通过实现对应的接口来实现动态代理。核心是InvocationHandler接口和proxy类，通过invoke（）方法来反射调用目标类中的代码，动态的将横切面和业务编制在一起。如果没有实现对应的接口会使用CGLIB来进行动态代理，CGLIB是通过动态的生成一个子类对象覆盖特定的方法实现动态代理

Aop优点可以降低耦合度，提高了代码的重用行，利于扩展和维护。

**aop中相关名词的概念：**

连接点：插入在方法的某个地方，前面，后面等等，这就是连接点。

切点：切点是一种规则，所有连接点的集合，在代码中execution表达式就是切点

通知：增强原有方法的功能，增强了什么，在代码上@before标签里面的代码就是通知。也就是说，通知就是指定要干什么。前置 after，后置before，正常返回  异常返回AftherThrowing，环绕 Around

切面：切点+通知就是切面。在代码中，加上了aspect标签的类就是切面

## Spring事务

Spring事务本质上是对数据库事务的支持，若没有数据库的事务支持，spring是无法提供事务支持的，且数据库底层事务的提交和回滚是通过binlog，redolog实现的。

事务管理分为声明式事务管理（仅仅使用注释或 XML 配置来管理事务）和编程式事务管理

Spring事务分为编程式事务和声明式事务。编程式事务在开发中用到的较少。用的较多的是声明式事务。

如何使用声明式事务，首先在xml中配置事务的配置信息，tx：annocation-deriven

然后在需要支持事务的类上或是方法上写上@Transactional标签。标签中默认事务的传播行为是required。即如果该方法有事务，就使用该方法的事务，如果该方法没有事务，就自己创建一个事务。传播行为有7中，我们使用的的最多的就是默认的传播事务。

spring是如何管理事务的？在执行支持事务的方法时，如果方法没有抛出异常，正常执行就会执行commit，如果方法抛出了异常，就会执行回滚。我们可以在标签中，设置robackfor的值指定回滚时机。rollbackfor：用于指定触发事务回滚的异常类型，用的最多是runtimeexception，还有throwable。值是.class

Spring事务实现原理：spring事务使用aop代理实现的，在代码运行时生成一个代理对象。然后根据transactional中的配置，由拦截器transactionalinterceptor拦截。当目标对象被拦截后，会在目标方法之前创建并加入事务，接着执行目标方法的逻辑，最后根据执行情况执行回滚或提交。

## pring事务的传播行为

REQUIRED（默认）：

如果当前存在事务，则加入到当前事务中；如果当前没有事务，则创建一个新的事务。该传播行为保证了方法执行时必须处于一个事务之中。

## 事务的特性

1、原子性（事务中的所有操作是一个整体）

2、一致性

3、隔离性

4、持久性

## 数据库的隔离级别

1、读未提交

2、读已提交

3、可重复读

4、序列化

## spring事务失效的场景

1、如果事务方法所在的类没有注册到 `Spring IOC`容器中，也就是说，事务方法所在类并没有被 `Spring`管理，则 `Spring`事务会失效。

2、有时候，某个方法不想被子类重新，这时可以将该方法定义成 `final`的。普通方法这样定义是没问题的，但如果将事务方法定义成 `final`会失效

3、如果事务方式不是 `public`修饰，此时 `Spring`事务会失效

4、 同一个类中的方法相互调用

6、 方法的事务传播类型不支持事务

7、 异常被内部catch，程序生吞异常

8、数据库不支持事务

## SSM如何整合

SSM是指Spring+SpringMVC+MyBatis，是一种常用的Java Web开发框架组合。它将Spring框架、SpringMVC框架和MyBatis持久层框架集成在一起，提供了一个全面的解决方案来开发Java Web应用程序

**Web.xml中的配置：**

1、通过context-param（param-name，param-value）配置spring父容器配置文件自定义的位置和名称。

2、通过servlet（servelt-name，servlet-class）配置springMVC子容器的前端控制器DispatcherServlet，通过配置load-on-startup进行置初始化的时机，-1默认，正数：服务器启动时就行实例化，负数：只有在客户端发送请求的时候才会进行实例化。还有servlet-mapping 中的url-pattern 设置为/

3、通过ContextLoaderListener,配置监听器listerer

4、配置过滤器fileter 在filter 中有url-mapping设置为 /* 配置需要拦截的路径Web.jsp不能直接放在web-inf下面/ 默认不能处理jsp请求

**父子容器的配置：**

 父容器：（spring.xml）

1、配置扫描组件:component-scan ,扫描dao和service

2、配置数据源文件dataSource

3、配置数据库连接池和参数

4、配置事务管理器transactionManager

5、配置sqlSessionFactoryBean

6、配置mybatis sqlSessionFactoryBean

**子容器springMVC.xml**

1、配置扫描控制层的组件component-scan

2、配置试图解析器，并配置试图的前缀和后缀

3、通过annotation-driven，配置开启mvc的注解驱动

4、配置拦截器 interceptor

5、配置跨域

## Spring三级缓存

用来解决相互依赖问题

**没有依赖**

    Getbean（A）->new instant(A)(不完全的A)将A写到一级缓存->到三级缓存进行赋值->赋值成功之后 ->将其放到一级缓存，清空二级缓存和三级缓存

**单个依赖**

**相互依赖**

Getbean（A）->new instant(A)(不完全的A)将A写到一级缓存->到三级缓存进行赋值（需要B）->没有B 加载B -> Getbean（B）->new
instant(B)(不完全的B)将B写到一级缓存->到三级缓存进行赋值发现需要A->回到一级缓存查找A（A为一个为赋值完全的A） ->进入二级缓存进行查找，没有-> 进入三级缓存发现了一个为赋值完全的A叫earlyBean（A）直接将A的代理类拿过来用将其放入二级缓存，此时B就赋值完成->将B写入到一级缓存，将二级缓存和三级缓存中的B进行清除，->A就可以拿到完全实例化的B，A就可以进行赋值，->f复制完成后就会将A也放到一级缓存中并且清除二级和三级中的A进行清除。

# SpringMVC

## Mvc执行流程

1、用户发送请求到前端控制器

2、前端控制器接受请求调用处理映射器查找处理器。

3、处理映射器找到具体的处理器(可以根据xml配置或者是注解进行查找) ，生成处理器对象和处理器拦截器的执行链返回给DispathcherServlet。

4、前端控制器调用处理器适配器

5、处理器适配器调用自定义的处理类（后端控制器）。

6、自定义处理类（也就是后端控制器）将得到的数据进行处理，并返回给处理器适配器。

7、处理器适配器将得到的结果返回给DispathcherServlet

8、DispathcherServlet将ModelAndView传给视图解析器。

9、试图解析器将得到的参数从逻辑试图转换为物理试图返回一个给前端控制器。

10、DispathcherServlet调用物理视图进行渲染并返回

## SpringMvc常用注解

1、@RequestMapper:用于处理请求url映射的注解，可以用在类上或者是方法上，用在类上表示类中的所有方法都以该地址作为父路径。

2、@RequestBody：注解接收http请求的json数据，将json转化为java对象。

3、@ResponseBody：注解实现将controller方法返回对象转化为json数据并返回

4、@PathVariable：用户从url路径上获取指定参数，标注在参数前

5、@RequestParam：标注在方法参数之前，用于对传入的参数做一些限制，支持三个属性

    Value：默认属性，用于指定前端传入的参数

    Required：用于指定此参数是否必传

DefaultValue：当参数为非必填参数的时候且前端没有传入参数的时候，用来指定一个默认值

6、@ControllerAdvic 标注在一个类上，表示该类是一个全局异常处理的类

7、@ExceptionHandler（类名。class）：标注在异常处理的方法上，表示该方法可以处理异常的类型

8、coresOrange

9、cookieValue

10、service

11、controller

12、RestController

@RequestHeader  获取请求头

## Spring配置跨域

**Xml方式：**

在Spring XML配置文件中，可以使用 `mvc:cors`标签来配置跨域。以下是一个示例：

```xml
<mvc:cors>
    <mvc:mapping path="/api/**"
                 allowed-origins="http://localhost:8080"
                 allowed-methods="GET, POST, PUT, DELETE"
                 allowed-headers="header1, header2"
                 allow-credentials="true"
                 max-age="3600"/>
</mvc:cors>
```

在上述示例中，`mvc:cors`标签用于配置跨域请求，`mvc:mapping`标签指定了需要进行跨域处理的路径，`allowed-origins`属性指定了允许的源地址，`allowed-methods`属性指定了允许的请求方法，`allowed-headers`属性指定了允许的请求头，`allow-credentials`属性指定了是否允许发送Cookie，`max-age`属性指定了预检请求的有效期。

1. 使用注解：可以在Controller类或方法上使用 `@CrossOrigin`注解来配置跨域。例如：

```java
@RestController
@CrossOrigin(origins = "http://localhost:8080")
public class MyController {
    // ...
}
```

2.使用配置类：可以创建一个配置类，继承 `WebMvcConfigurerAdapter`类，并重写 `addCorsMappings`方法来配置跨域。例如：

```java
@Configuration
public class MyConfig extends WebMvcConfigurerAdapter {
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
                .allowedOrigins("http://localhost:8080")
                .allowedMethods("GET", "POST", "PUT", "DELETE")
                .allowedHeaders("header1", "header2")
                .allowCredentials(true)
                .maxAge(3600);
    }
}
```

3.使用过滤器：可以创建一个过滤器来处理跨域请求。例如：

```java
@Component
public class CorsFilter implements Filter {
    @Override
    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
            throws IOException, ServletException {
        HttpServletResponse response = (HttpServletResponse) res;
        response.setHeader("Access-Control-Allow-Origin", "http://localhost:8080");
        response.setHeader("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE");
        response.setHeader("Access-Control-Allow-Headers", "header1, header2");
        response.setHeader("Access-Control-Allow-Credentials", "true");
        response.setHeader("Access-Control-Max-Age", "3600");
        chain.doFilter(req, res);
    }
}
```

## 重定向和转发

转发：forward方式：在返回值前面加forward 比如：forward：user.do?name=zs

重定向：redirect方式：在返回值前面加redirect 比如redirect：[http://www.baidu.com](http://www.baidu.com)

## Spring、Spring MVC、Spring Boot和Spring Cloud 四个的区别

这四个名词（Spring、SpringMVC、Spring Boot和Spring Cloud）都是指的是Spring框架及其子项目。让我们来看看它们的主要区别：

Spring: 这是一个开源的Java/JavaEE全栈轻量级应用框架，提供了一系列的服务，如依赖注入（DI）、面向切面编程（AOP）、事务管理等等，让开发者可以更加容易地开发出松耦合的应用程序。

Spring MVC: Spring MVC是Spring框架的一部分，是一个提供了**模型-视图-控制器（MVC）架构**和可以用来创建可扩展性强的多层**Java Web应用的框架**。它处理了诸如**请求映射、数据绑定**等等的基础工作。

Spring Boot: Spring Boot是Spring的一个子项目，目的在于简化Spring应用的初始搭建以及开发过程。Spring Boot通过提供各种默认配置来使项目更加快速和便捷的进行，它也包括了一个运行器，可以直接运行应用，无需额外的服务器。

Spring Cloud: Spring Cloud是一套完整的微服务解决方案的框架，包含了微服务通信、配置中心、服务发现、断路器、路由、负载均衡、网关等组件。它基于Spring Boot构建，使得开发分布式系统变得简单。

总结一下，Spring框架提供了创建企业级Java应用程序的基础架构。Spring MVC是这个框架的一个组成部分，专门用于构建Web应用程序。Spring Boot则简化了使用Spring进行开发的过程，使开发者更容易创建Spring应用程序。Spring Cloud则是在Spring Boot的基础上，为开发微服务架构提供了一整套解决方案。

# Spring Boot

## springboot常用注解

@SpringBootApplication：标记启动类，用于表示应用的入口。

@ConfigurationProperties：将配置文件中的属性值与 Java 类型绑定起来。

@EnableAutoConfiguration：自动配置 Spring 应用上下文。

@ConditionalOnProperty：条件化配置注解，根据配置属性是否存在来决定是否加载一个 Bean 等组件

@EnableScheduling：标注在启动类上，用于开启定时任务的支持。

@ComponentScan：用于指定项目扫描的包，默认加载启动类所在的包以及子包中的类。

@Import(RestTemplate.class) ：用于配置类，RestTemplate等同于ssm中的httpClient。

@Value：用于注入配置参数的值。

@Mapper：标注在dao层接口。

@EnableDubbo：在启动类打，表示启动dubbo服务。

@DubboService：用于服务端标注该类为dubbo service层。

@DubboReference：用于消费端依赖注入接口实现类。

## SpringBoot自动装配

1.新建一个工程名为XXXstarter的工程

2.引入相应的依赖springbootstart，业务处理的一些以来

3.业务逻辑类（主要）

4.定义配置类（如AOP的配置）

5.定义自动配置类创建spring.factories

写自动装配的逻辑，各种条件注入的注解，@ConditionalOnClass，

@ConditionalOnMissingBean，ConditionalOnProperties等

Spring Boot 的自动装配原理是其核心功能之一，它基于Spring框架，提供了简化应用程序配置和部署的便利性。下面是关于Spring Boot自动装配原理的简要分析：

条件注解（@Conditional）：Spring Boot利用条件注解来实现自动装配。条件注解是Spring框架的一项功能，它允许我们根据特定的条件来控制Bean的创建和装配。Spring
Boot通过条件注解来判断是否满足特定的条件，从而决定是否装配相关的Bean。

自动配置类（Auto-Configuration）：Spring Boot中的自动配置类是关键部分。这些类通过条件注解来标记，它们定义了应用程序所需的一组默认配置。当启动Spring Boot应用时，自动配置类会被加载，并根据条件注解判断是否需要应用自动配置。

SpringApplication类：SpringApplication是Spring
Boot的核心类之一，它负责应用程序的启动和初始化。在初始化过程中，SpringApplication会扫描classpath下的自动配置类，并根据条件注解来判断是否需要应用这些自动配置。如果满足条件，自动配置类中定义的配置将被应用。

自动装配原理：当Spring Boot应用启动时，Spring容器会根据自动配置类中定义的条件，扫描并加载相关的自动配置。自动配置类中通常包含了一些Bean的定义，这些Bean会根据条件进行创建和装配。Spring Boot会根据类路径、配置文件、系统属性等信息，自动检测并加载需要的自动配置类，从而实现自动装配的功能。

总体而言，Spring Boot的自动装配原理是通过条件注解和自动配置类来实现的。自动配置类定义了一组默认的配置，根据条件注解判断是否需要应用这些配置。在应用启动时，Spring Boot会扫描并加载自动配置类，并根据条件进行自动装配，简化了应用程序的配置和部署过程。这种机制使得开发者可以更加方便地搭建和管理Spring Boot应用。

##### springboot 自动配置是什么？原理是

Spring Boot的自动配置是一种**方便的功能**，它可以帮助开发者**自动设置和配置项目**。这种功能主要是依据classpath上的jar依赖，有条件地配置Spring应用程序。你添加什么库，Spring Boot就会增加相应的自动配置。例如，如果你的classpath上有H2和Spring
Data JPA库，那么Spring Boot会自动配置内存数据库和设置JPA。

Spring Boot自动配置的基础是@SpringBootConfiguration，这是一种特殊类型的@Configuration。Spring Boot在启动时会去寻找并加载所有的@SpringBootConfiguration。

自动配置的核心机制在于 @EnableAutoConfiguration 注解，这个注解会启用 Spring Boot 的自动配置功能。@EnableAutoConfiguration
的作用是收集并加载所有在类路径下 META-INF/spring.factories 配置文件中的类。Spring Boot 会读取这些文件，并且查找 key 为 org.springframework.boot.autoconfigure.的项，然后把他们注册为bean。

自动配置尝试根据添加的jar依赖自动配置你的Spring应用。例如，如果你的classpath下有HSQLDB，而你并没有配置任何数据库连接的Beans，那么Spring Boot将自动配置一个内存（in-memory）数据库。

注意，自动配置是非侵入式的。自动配置不会在你定义了自己的配置的情况下尝试去改变。例如，如果你自定义了DataSource bean，那么默认的数据库配置就会失效。

也就是说，Spring Boot的自动配置是一种“开箱即用”的设计，能够帮**助开发者省去大量的配置时间，提升开发效率**。你只需要根据项目需要添加对应的依赖，然后Spring Boot就会为你自动完成大部分的基础配置。

## Spring Boot 部署 war 包

要将Spring Boot应用程序打包为WAR文件并进行部署，可以按照以下步骤进行操作：

1. 修改pom.xml文件：在Spring Boot项目的pom.xml文件中，将packaging设置为war：

   ```
   <packaging>war</packaging>
   ```
2. 添加Servlet支持：在pom.xml文件中，添加Servlet API和JSP支持的依赖：

   ```
   <dependencies>
       <!-- 其他依赖 -->

       <dependency>
           <groupId>javax.servlet</groupId>
           <artifactId>javax.servlet-api</artifactId>
           <scope>provided</scope>
       </dependency>
       <dependency>
           <groupId>javax.servlet.jsp</groupId>
           <artifactId>javax.servlet.jsp-api</artifactId>
           <scope>provided</scope>
       </dependency>
       <dependency>
           <groupId>javax.servlet.jsp.jstl</groupId>
           <artifactId>javax.servlet.jsp.jstl-api</artifactId>
           <scope>provided</scope>
       </dependency>
   </dependencies>
   ```
3. 修改启动类：将Spring Boot的启动类（通常带有 `@SpringBootApplication`注解）扩展 `SpringBootServletInitializer`类，并重写 `configure`方法：

   ```
   import org.springframework.boot.builder.SpringApplicationBuilder;
   import org.springframework.boot.web.servlet.support.SpringBootServletInitializer;

   public class ServletInitializer extends SpringBootServletInitializer {

       @Override
       protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
           return application.sources(YourSpringBootApplication.class);
       }

   }
   ```
4. 打包应用程序：使用Maven命令将Spring Boot应用程序打包为WAR文件：

   ```
   mvn clean package
   ```
5. 部署WAR文件：将生成的WAR文件复制到Servlet容器（如Tomcat）的webapps目录下，并启动容器。

注意：在部署WAR文件时，确保Servlet容器的版本与应用程序的依赖项兼容。另外，如果应用程序中使用了嵌入式的Servlet容器（如Spring Boot内置的Tomcat），则不需要进行WAR部署，可以直接运行应用程序的JAR文件。

# Spring Cloud

## springcloud Alibaba有哪些组件

Spring Cloud Alibaba 是一个基于 Spring Cloud 体系的一站式企业级微服务解决方案，它是由阿里巴巴集团开源的。Spring
Cloud Alibaba 项目包含以下组件：

Nacos（Naming and Configuration Service）：一个易于使用的服务发现、配置管理和服务管理平台。

Sentinel：一款高可用性的、熔断降级，服务限流框架（qps，线程数），可实现精细化的流量控制。

RocketMQ：一个分布式消息中间件，具有高可用、高性能、高扩展性等特点。

Seata：一个分布式事务解决方案，支持本地微服务和云原生场景的分布式事务处理。

Dubbo：阿里巴巴开源的高性能、轻量级 RPC 框架，支持多种序列化和通讯协议。

    分布式系统中基于接口的远程服务框架

Alibaba Cloud ACM：一款针对云原生应用设计的配置管理平台，可实时同步配置、实现动态配置、故障恢复等。

Alibaba Cloud OSS：阿里云对象存储服务，具有高扩展性、高可用性等特点，方便用户存储和管理海量数据。

Alibaba Cloud SMS：阿里云短信服务，提供全球短信发送和接收服务，可用于注册验证、营销推广、通知提醒等场景。

此外，Spring Cloud Alibaba 还提供对 Spring Cloud Gateway、Spring Cloud Alibaba
Sentinel RSocket、Spring Cloud Alibaba Seata 的支持，并为用户提供与 Spring Boot、Spring Cloud 无缝集成的开发体验。

# Redis

## 什么样的数据放在redis里面

 可序列化，数据量少，一致性要求不高，读远大于写，访问频率高的

1、数据可以被序列化的（Redis存储的是键值对，其中的值需要能够被序列化为字符串，所以你可以存储的数据类型受此限制。）

2、数据量不大的

3、用于实时分析，实时操作，访问频率高的数据

4、数据一致性要求不高的（数据可能在某些情况下会丢失，因此，对于需要高度一致性的数据，如交易系统中的订单信息，）

5、读取操作远多于写入操作的

## 分布式锁：

分布式锁是用于在分布式系统中实现资源的互斥访问的一种机制。常见的分布式锁的三种实现方式包括：

1. 基于数据库的实现方式：通过在数据库中创建一个表或者集合，使用数据库的事务特性来实现分布式锁。具体实现方式是，在获取锁时向数据库中插入一条记录，并将**记录的主键设置为锁的名称**，如果插入成功则表示获取到锁，否则表示锁已被其他进程占用。释放锁时，删除对应的记录即可。
2. 基于缓存的实现方式：通过使用分布式缓存系统，如Redis、Memcached等，来实现分布式锁。具体实现方式是，使用缓存系统的原子性操作（如setnx）来设置锁的键值对，如果设置成功则表示获取到锁，否则表示锁已被其他进程占用。释放锁时，删除对应的键值对即可。
3. 基于ZooKeeper的实现方式：通过使用ZooKeeper来实现分布式锁。具体实现方式是，利用ZooKeeper的有序节点特性，在获取锁时创建一个有序的临时节点，并获取所有比自己小的节点的列表，如果自己是最小的节点则表示获取到锁，否则监听自己前一个节点的删除事件。释放锁时，删除自己的节点即可。

这三种实现方式各有优缺点，选择适合自己业务场景的方式进行实现。基于数据库和缓存的实现方式相对简单，但可能存在单点故障和性能瓶颈的问题。基于ZooKeeper的实现方式相对复杂，但具有高可用性和可靠性。

## Redis持久化机制

Redis 为了保证效率，数据缓存在了内存中，但是会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件中，以保证数据的持久化。

Redis 的持久化策略有两种：
RDB：**快照**形式是直接把内存中的数据保存到一个dump.rdb 的文件中，定时保存，保存策略。
AOF：把所有的对Redis 的服务器进行修改的命令都存到一个文件里，命令的集合。Redis默认是快照 RDB的持久化方式。当Redis 重启的时候，它会优先使用 AOF文件来还原数据集，因为 AOF文件保存的数据集通常比 RDB文件所保存的数据集更完整。你甚至可以关闭持久化功能，让数据只在服务器运行时存。

## redis缓存

**缓存击穿** ：是指在缓存中没有数据（数据过期了），但是在数据库中有数据。这时由于并发访问的用户数较多，在缓存中查询不到数据后同时去数据库中查询，造成数据库压力较大。

解决：

1. 设置热点数据永不过期
2. 加互斥锁。击穿的原因之一是并发查询，此时加个互斥锁，让用户排队查询。

**缓存穿透** ：是指缓存和数据库中都没有的数据。用户此时发起请求，但是因为缓存和数据库中都没有数据，导致用户一直不断请求这个数据，使数据库压力过大。

解决：用户查询没有结果的数据后返回一个代表空值的值。

**缓存雪崩** ：是指缓存数据大批量同时到期，而查询的数据量过大，导致数据都从数据库中查询，使数据库压力过大。和缓存击穿不同的是，雪崩是大批量不同的数据同时过期了，击穿是并发查询同一条数据。

解决：

1. 将缓存过期时间设置随机，避免同时过期的情况。
2. 如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中。
3. 设置热点数据永远不过期。

## redis事务

redis对事务的支持目前还比较简单。Redis只能保证一个client发起的事务中的命令可以连续的执行，而中间不会插入其他client的命令。当一个client在一个链接中发出多命令时，这个连接会进入一个事务中，该连接后续的命令不会立即执行，而是先放在一个队列当中，当执行exec命令的时候，redis会顺序的执行**队列**中的所有命令。

## redis的五种数据类型

Redis 是一种高性能的内存数据存储系统，它支持多种数据类型。以下是 Redis 中常用的五种数据类型：

1. 字符串（String）：字符串是 Redis 最基本的数据类型，可以存储任意类型的数据，包括文本、数字等。字符串类型的值最大可以达到 512MB。
2. 列表（List）：列表是一个有序的字符串集合，可以在列表的两端进行插入和删除操作。可以用来实现队列（Queue）或栈（Stack）等数据结构。
3. 哈希（Hash）：哈希是一种键值对存储结构，类似于关联数组或字典。在 Redis 中，哈希可以存储多个字段和对应的值，常用于存储对象或实体的属性。
4. 集合（Set）：集合是一个无序的字符串集合，不允许重复的元素。可以进行集合间的交集、并集、差集等操作，还可以快速判断一个元素是否存在于集合中。
5. 有序集合（Sorted Set）：有序集合是集合的扩展，每个元素都关联一个分数（Score），并按照分数进行排序。可以根据分数范围获取元素，还可以为元素设置权重和排序优先级。

通过使用不同的数据类型，Redis 提供了丰富的功能和灵活的数据操作方式。开发者可以根据具体的业务需求选择合适的数据类型来存储和操作数据。

## redis常用操作命令

1. **SET key value**: 设置指定 key 的值为给定的 value。
2. **GET key**: 获取指定 key 的值。
3. **DEL key**: 删除指定的 key。
4. **EXISTS key**: 检查指定的 key 是否存在。
5. **TTL key**: 获取指定 key 的过期时间（以秒为单位）。
6. **KEYS pattern**: 查找所有符合给定模式的 key。
7. **INCR key: 将指定 key 的值递增 1。**
8. **DECR key: 将指定 key 的值递减 1。**
9. **HSET key field value**: 在指定的哈希表中设置字段(field)的值。
10. **HGET key field**: 获取指定哈希表中指定字段的值。
11. **HDEL key field**: 删除指定哈希表中的一个或多个字段。
12. **LPUSH key value1 [value2 ...]**: 将一个或多个值插入到列表的头部。
13. **RPUSH key value1 [value2 ...]**: 将一个或多个值插入到列表的尾部。
14. **LPOP key**: 移除并返回列表的头元素。
15. **RPOP key**: 移除并返回列表的尾元素。
16. **SADD key member1 [member2 ...]**: 向集合添加一个或多个成员。
17. **SMEMBERS key**: 返回集合中的所有成员。
18. **SREM key member1 [member2 ...]**: 从集合中移除一个或多个成员。
19. **ZADD key score1 member1 [score2 member2 ...]**: 向有序集合添加一个或多个成员，或者更新已存在成员的分数。
20. **ZRANGE key start stop**: 根据索引区间返回有序集合中的成员。

# 分布式事务：

分布式事务是指在分布式系统中，涉及多个独立的节点或服务的操作，这些操作需要保证原子性、一致性、隔离性和持久性（ACID）的特性。在分布式环境下，由于网络延迟、节点故障等原因，保证事务的一致性变得更加复杂。

为了解决分布式事务的问题，有几种常见的分布式事务解决方案：

1. 二阶段提交（2PC）：

   - 第一阶段（准备阶段）：事务协调者（Transaction Coordinator）向所有参与者（Transaction Participant）发送准备请求，并等待参与者的响应。参与者执行事务的准备操作，并将准备结果（同意或中止）发送给事务协调者。
   - 第二阶段（提交阶段）：如果所有参与者都同意提交事务，事务协调者向所有参与者发送提交请求，参与者执行事务的提交操作。如果任何一个参与者拒绝提交事务或者在超时时间内未响应，事务协调者向所有参与者发送中止请求，参与者执行事务的回滚操作。
2. 三阶段提交（3PC）：

   - 第一阶段（CanCommit阶段）：事务协调者向所有参与者发送CanCommit请求，并等待参与者的响应。参与者执行事务的准备操作，并将准备结果（同意、中止或等待）发送给事务协调者。
   - 第二阶段（PreCommit阶段）：如果所有参与者都同意提交事务，事务协调者向所有参与者发送PreCommit请求，参与者执行事务的预提交操作，并将预提交结果发送给事务协调者。
   - 第三阶段（DoCommit阶段）：事务协调者收到所有参与者的预提交结果后，如果都成功，则向所有参与者发送DoCommit请求，参与者执行事务的提交操作。如果任何一个参与者预提交失败或者在超时时间内未响应，事务协调者向所有参与者发送Abort请求，参与者执行事务的回滚操作。
3. 补偿事务（Compensating Transaction）：补偿事务是一种通过执行相反操作来回滚事务的方式。在补偿事务模式中，每个参与者都有一个补偿操作，用于撤销或修复已经执行的操作。如果事务执行失败，参与者执行补偿操作来回滚事务。补偿事务模式相对灵活，但需要开发人员手动实现补偿操作。
4. TCC（Try-Confirm-Cancel）：TCC是一种基于补偿事务模式的分布式事务解决方案。在TCC中，事务分解为Try、Confirm和Cancel三个阶段。在Try阶段，事务参与者尝试执行事务操作并预留资源；在Confirm阶段，事务参与者执行实际的事务提交操作；在Cancel阶段，事务参与者执行事务的回滚操作。TCC通过细粒度的控制和补偿操作来实现事务的一致性。

总之，分布式事务是在分布式系统中保证多个操作的原子性、一致性、隔离性和持久性的机制。不同的分布式事务解决方案有不同的特点和适用场景，开发人员需要根据具体需求选择合适的解决方案。

# MQ

## 如何保证RabbitMQ中消息的顺序性？

RabbitMQ本身并不保证消息的严格顺序性。但可以通过以下方式实现近似的消息顺序性：

使用单个队列：将具有相同顺序要求的消息发送到同一个队列，由同一个消费者按序处理。

设置队列级别的单一消费者模式：通过限制队列只能被一个消费者订阅，确保消息按照发送顺序被处理（每个消费者值监听一个队列）。

在消息中包含序列号或时间戳：在消息的属性或内容中添加一个序列号字段，消费者在处理消息时根据序列号进行顺序性处理。

1、生成序列号或时间戳

2、将序列号或时间戳附加到消息中

3、消费者缓存和排序消息

4、处理排序后的消息

## 消息队列应用场景和用途

消息队列是一种在应用程序之间传递消息的通信机制。它解耦了消息的发送者和接收者，提供了异步通信的能力，可以实现高效、可靠的消息传递。

使用消息队列可以实现以下功能：

1. 异步通信：发送者发送消息后，可以立即返回，不需要等待接收者处理完毕。这样可以提高系统的响应速度和吞吐量。
2. 解耦和削峰：发送者和接收者之间通过消息队列进行通信，彼此之间不直接依赖。这样可以降低系统的耦合度，并且当接收者处理能力不足时，消息队列可以缓冲消息，避免系统崩溃。
3. 可靠性保证：消息队列通常具有持久化机制，可以将消息存储在磁盘上，确保消息在传递过程中不会丢失。同时，消息队列还可以实现消息的重试、重复消费等机制，提高系统的可靠性。
4. 广播和订阅：消息队列可以支持发布-订阅模式，一个消息可以同时被多个订阅者接收。

常见的消息队列系统包括RabbitMQ、Kafka、ActiveMQ等，它们都提供了丰富的功能和易于使用的API，可以满足不同场景下的需求。

## Mq三大功能

1、异步通讯：主要用于强调消息并行执行还是串行执行。将消息先放下，然后自己继续去执行

2、销锋填谷：采用队列进行一步步的进行处理

3、应用解耦：将对应的订单或者支付操作进行分解开来，只用当所有的一些数据处理完成之后才会进行下一步进行等待，还有可能就是

# shoir

## 　1、简单介绍一下Shiro框架?

　　答：Shiro是Java的安全框架。使用Shiro可以很容易地开发出足够好的应用程序。它不仅可以用于JavaSE环境，也可以用于JavaEE环境。Shiro可以帮助我们完成认证、授权、加密、会话管理、与Web集成、缓存等功能。

　　三个核心组件分别是Subject，SecurityManagerRealms。

## 　　2、Shiro的主要组件?

　　答：(1)SecurityManager：典型的Facade，Shiro通过它提供各种外部安全管理服务;(2)Authenticator：对“Who are you?”进行核实。通常涉及用户名和密码。该组件负责收集principals 并向应用系统提交credentials。如果提交的credentials和应用系统提供的 如果credentials一致，可以继续访问，否则需要重新提交principals和credentials，或者直接访问 终止访问;(3)Authorizer：身份验证通过后，该组件将对登录人员进行访问控制筛选，如“who can do what”，或者“who can do which actions”。Shiro采用“基于Realm”方法，即用户 (又称Subject)、用户组、角色和permission的聚合物;(4)Session Manager：该组件保证了异构客户端的访问，配置简单。它是基于POJO/J2SE，没有任何关系 绑定客户端或协议

　　3、资源实例的控制称为细粒度权限管理，即控制到数据级别的权限。例如，用户只允许修改本部门的员工信息，用户只允许导出自己创建的订单细节。

## 　　6、如何授权粗粒和细粒?

　　答:对于粗粒度的授权，很容易做到系统结构级功能，即系统功能操作采用统一的粗粒度权限管理。对于细粒度的授权，不建议制作系统架构级功能，因为数据级别的控制是系统的业务需求。随着业务需求的变化，业务功能发生变化的可能性很大。建议将数据级别的权限控制在业务层面进行个性化开发。例如，用户只允许修改他们创建的商品信息实现了service接口的添加验证。service接口需要输入当前操作员的标识。如果与商品信息创建者的标识不一致，则不允许修改商品信息。

　　粗颗粒权限：过滤器可用于统一拦截url。

　　细颗粒权限：在控制service，控制程序级别，个性化编程。

## 　　7、shiro有什么优点?

　　答：简单的身份验证，支持各种数据源;简单授权角色，支持细粒度授权;支持一级缓存，以提高应用程序的性能;基于内置适用于web和非web环境的POJO企业会话管理;非常简单的API加密;不绑定任何框架，可独立运行。

## 　　8、Spring如何配置? Shiro?

　　答：首先在 web.xml 中配置 Shiro 的 Filter;其次在 Spring 配置在配置文件中 Shiro:

　　> 配置自定义 Realm：实现自定义认证和授权

　　> 配置 Shiro 实体类使用的缓存策略

　　> 配置 SecurityManager

　　> 配置保证 Shiro 内部 Bean 声明周期已经执行。 Lifecycle Bean 后置处理器

　　> 配置AOP 方法级权限检查

　　> 配置 Shiro Filter

## 　　9、比较 Spring Security和Shiro?

　　答：相比Spring Security, Shiro 在保持强大功能的同时， 使用简单和灵活性;Spring 即使是一个简单的请求，Security也必须经过至少8个Filter;

　　Spring Springrity必须是Spring 在环境中使用。

## 　　10、Shiro授权过程是什么?

　　答：(1)调用任何Subjecthasrole*的应用程序或框架代码， checkRole*, is Permitted*,或者check Permission*变体的方法， 传递任何所需的权限;(2)Subject 的实例 调用security使用security Manager 对应的方法，Subject 实例;(3)

　　Security Manager调用orger.apache.shiro.authz.Authorizer 默认情况下，接口的对应方法，authorizer 实例是一个 Modular Realm Authorizer实例， 它支持在任何授权操作过程中协调一个或多个Realm 实例;(4) 每一个配置都很好 Realm 被检查是否实现了相同的检查 Authorizer 接口. 如果是, Realm 各自的 hasRole*, checkRole*,isPermitted*，或 checkPermission* 该方法将被调用

# MyBatis

## Mybatis标签

resuptMap：处理查询的结果集合实体类属性之间的映射关系。

Collection是处理一对多的映射

association：是处理多对一的映射

sqlmap：将重复的sql语句放进sqlmap中，然后使用的时候直接引用。

动态sql：需要拼接sql语句的时候使用，增加sql语句的灵活性。

标签：if标签，判断sql中的条件是否满足，满足就拼接在where后面，不满足就扔掉。

Where：代替where1=1的作用

foreach标签，代替sql中的in。

foreach标签的属性含义如下： 标签用于遍历集合，它的属性：

    collection：代表要遍历的集合元素，注意编写时不要写#{}

    open：代表语句的开始部分

    close：代表结束部分

    item：代表遍历集合的每个元素，生成的变量名

    sperator：代表分隔符

# Nginx

Nginx是一个反向代理服务器（用户不知道具体的服务器）。用来实现动静分离和负载均衡。

所谓动静分离就是当服务器接收到访问静态资源的请求时，nginx不会将请求转发到web服务器，而是会自己根据请求查找到本地相应的静态资源，然后返回给客户端。

在nginx的配置文件中，通过修改location中匹配的访问路径，然后匹配到访问静态资源的请求，接着根据root中的配置，在本地查找到后返回。

**负载均衡怎么做?**

首先在location中配置访问web服务器的路径，然后配置proxy_pass，接着配置upstream，upstream后面的值和proxy_pass的一样。Upstream里面的server 就是负载均衡的ip。负载均衡的常用策略：轮询，iphash。

轮询存在的问题，session共享问题。Iphash存在的问题：可能会出现不同的ip hash到同一个服务器上，导致服务器压力过大。

如何解决？使用轮询+redis的策略。使用redis保存session。

**Location** **路径匹配顺序：** =，^~，~，/

=是精确匹配

^~和~是正则匹配，

有^的正则匹配更优先。/是通配，如果前面三个都没有匹配上，就会进入通配/（模糊匹配）。

# http协议

http协议超文本传输协议（Hyper
Text Transfer Protocol）:是一种位于应用层超文本传输协议，在客户端和服务端之间通信，就是说通过再浏览器的地址栏上输入对应的地址信息，客户端会将对应的DNS域名转化为ip地址，通过ip地址找到对应的服务器进行访问。

**它是一种短连接，无状态的协议。**

**短连接**是指一次请求和响应后，连接一会就关闭，这种方式可以节省资源。

无状态是指服务端在收到客户端发来的消息后，只知道收到了一条消息，并不知道是谁发送的。解决这个问题可以在客户端加上cookie。

http协议分为请求协议和响应协议:

### 请求协议：

 **请求首行 ** （GET/servletLearn/s1 HTTP/1.1） 请求方式 uri 协议版本号

**请求头**  key：value形式，常见的参数content-type,content-length，host，cookie等

**请求空行**

 **请求体** ：传输数据 （get请求没有请求体）

![image-20230903140618076](../../AppData/Roaming/Typora/typora-user-images/image-20230903140618076.png)

    **  常用的几种请求方式** ：Get，Post，Put，Head，Delete，Options，Trace， Conntection

### 响应协议：

**响应首行** （HTTP响应状态码：1xx—5xx  1xx  100：未返回数据，2xx  200：成功返回数据，3xx  302：重定向4xx：前台错误 400 Bad Request：请求参数有误，404请求路径错误，405 请求方法错误,415 请求格式错误(json,from) 401需要身份验证 5xx：后台错误 500：服务器内部错误，无法完成请求 1.1200）协议版本号 响应状态码

**响应头**  key：value形式

**响应空行**

**响应体：**

![image-20230903140644439](../../AppData/Roaming/Typora/typora-user-images/image-20230903140644439.png)

### http和https有什么不同?

HTTP协议传输的数据都是未加密的，也就是明文的

http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

# 多线程

## 实现线程的三种方式

1、继承Thread类：创建一个新的类并继承Thread类，重写run()方法来定义需要执行的任务，然后通过创建该类的实例对象来启动线程。

2、实现Runnable接口：创建一个实现Runnable接口的类，并实现其run()方法，通过创建该类的实例对象，并将其作为Thread类的构造方法参数来启动线程。

3、实现Callable接口：创建一个实现Callable接口的类，并实现其call()方法，可以返回执行结果。然后通过创建该类的实例对象，并将其作为FutureTask类的构造方法参数，再创建Thread类来启动线程。

继承thread类，实现runnable接口，实现callable接口（有返回值），实现future接口（Future接口提供方法来检测任务是否被执行完 **isDone** ()，等待任务执行完获得结果，也可以设置任务执行的超时时间**get** (long timeout, TimeUnit unit)。

### Runnable和Callable的区别

两点：返回值，异常

## 多线程的种同步工具

### CountDownLatch

是一个同步工具类，用来协调多个线程之间的同步，起到线程之间通信的作用。Countdownlatch使用计数器实现，每当有一个线程完成后，计数器就加一或者减一。当所有的线程都完成后，等待的线程就会恢复当计数器的值为0时，表示所有的线程都已经完成一些任务，然后在CountDownLatch上等待的线程就可以恢复执行接下来的任务。

一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。

new CountDownLatch(n)

### Cyclicbarrie

CyclicBarrier和CountDownLatch的区别

1）CountDownLatch简单的说就是一个线程等待，直到他所等待的其他线程都执行完成并且调用countDown()方法发出通知后，当前线程才可以继续执行。

2）cyclicBarrier是所有线程都进行等待，直到所有线程都准备好进入await()方法之后，执行条件变量的signalAll方法唤醒等待的线程。所有线程同时开始执行！

3）CountDownLatch的计数器只能使用一次。而CyclicBarrier的计数器可以使用reset() 方法重置。所以CyclicBarrier能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次。

### 信号灯 Semaphore

（可以控制同时访问资源的线程数量）

获取灯：sp.acquire()；释放灯:sp.release();

## 线程的生命周期（5个  新建，就绪，运行，阻塞，死亡）

![image-20230902152810600](../../AppData/Roaming/Typora/typora-user-images/image-20230902152810600.png)

## CAS(自旋)

原子类 会产生ABA问题，CAS 用于解决ABA问题

为了解决ABA问题，Java提供了AtomicStampedReference和AtomicMarkableReference两个类。这些类在CAS操作的基础上，增加了一个标记位或者时间戳，用于判断变量是否发生过变化。（AtomicStampedReference）解决aba问题就是在修改值时，加一个版本号或时间戳。

比较再交换，是一种乐观锁机制，没有使用synchronized。CAS有3个操作数，内存值v1，v2，旧的预期值v5，自增量v4。当且仅当预期值v5和内存值v1，v2相同时，将内存值V修改为v5+v4，否则循环比较。

## 读写锁

```
ReadWriteLock rwl=new ReentrantReadWriteLock(); 
rwl.readlock.lock();
rwl.readLock().unlock()
写在finally中; rwl.writeLock().lock();rwl.writeLock().unlock();
```

## volatile

修饰变量的关键字， **可见性** 。线程在工作的时候有一个工作内存，内存中有主内存区。当使用vlo编关键字后，线程修改的变量可以直接从工作内存中更新到主内存。然后其他线程取的时候，一定是最新的值。保证了可见性。Vol和cas一起就保证了原子性。

## 4种线程池

```
newsinglethreadexecutor，newfixedthreadpool，newcachedthreadpool，newschedulethreadpool
```

https://blog.csdn.net/lhd992692552/article/details/122498816

## 自定义线程池的7个参数

核心线程池数量，最大核心线程池数量，超时时间，超时单位，阻塞队列，线程工厂，拒绝策略(4种，丢弃抛异常，只丢弃不抛异常，喜新厌旧，拒绝之后由调用线程直接执行此任务)

## 并发编程三要素：解决线程安全问题

当多个线程要共享一个实例对象的值的时候，那么在考虑安全的多线程并发编程时就要保证下面3个要素。

原子性（Synchronized, Lock）一个或某几个操作只能在一个线程执行完之后，另一个线程才能开始执行该操作，也就是说这些操作是不可分割的，线程不能在这些操作上交替执行。

可见性(Volatile，Synchronized,Lock)一个线程对共享变量的修改,另一个线程能够立刻看到。

有序性(Volatile，Synchronized,Lock)程序执行的顺序按照代码的先后顺序执行。（处理器可能会对指令进行重排）。

当完成了并发三要素后，自然也就解决了线程安全问题。

线程安全问题：当多个线程访问某个方法时，不管你通过怎样的调用方式、或者说这些线程如何交替地执行，我们在主程序中不需要去做任何的同步，这个类的结果行为都是我们设想的正确行为，那么我们就可以说这个类是线程安全的。

## 乐观锁，悲观锁：

悲观锁：在select语句后加for update。这样在处理数据的过程中，数据是被锁定的，只有自己可以对数据进行操作，其他事务可以查询但不可以修改，但查询的不是最新的，这种情况是非一致性锁定读。

乐观锁是基于数据版本机制实现的。就是为数据增加一个版本号或者是时间戳。读取数据时，将版本号一同读取，在修改数据时，将版本号+1，在提交的时候先看一下版本号是否一致，如果一致就提交，如果不一致就是过期数据。

## sleep和wait区别

sleep是来自于Thread类，wiat是来自于Object类

线程sleep后，不会释放锁，进入阻塞队列。线程wait后释放了锁，进入等待队列。

sleep可以在任何地方使用，wait只能在同步代码里使用

## synchronized和Lock的异同

主要相同点：Lock能完成synchronized所实现的所有功能；

主要不同点：

Syschronized是一个关键字，而Lock是一个类；

Lock有比synchronized更精确的线程语义和更好的性能，而且不强制性的要求一定要获得锁；

Syschronized同步数据少量的话，性能比Lock好，而数据大量同步，Lock性能要好

synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且最好在finally块中释放（这是释放外部资源的最好的地方）。

## 进程和线程的区别

1. 资源分配：进程是操作系统分配资源的基本单位，每个进程都有独立的地址空间、文件描述符、打开的文件等。而线程是在进程内部创建的，共享进程的资源，包括地址空间、文件描述符等。
2. 执行方式：进程是独立执行的，拥有自己的程序计数器（PC）、寄存器集合和堆栈空间。而线程是在进程内部执行的，共享进程的上下文环境，包括PC、寄存器和堆栈。
3. 切换开销：由于进程拥有独立的地址空间和资源，进程间切换的开销比较大。而线程共享进程的资源，线程间切换的开销较小。
4. 通信方式：进程间通信需要使用操作系统提供的机制，如管道、消息队列、共享内存等。而线程间通信可以直接通过共享内存等方式进行。
5. 并发性：由于进程间资源独立，进程间的并发性较低。而线程共享进程的资源，线程间的并发性较高。

## AtomicInteger

`AtomicInteger` 是 Java 中提供的原子操作类之一，用于对整型数据进行原子性操作。它可以确保在多线程环境下对整型数据的操作是线程安全的，避免了竞态条件和数据不一致的问题。

`AtomicInteger` 类提供了一系列的方法来进行原子性操作，包括自增、自减、加法、减法、获取当前值等。下面是一些常用的方法：

1. `int get()`：获取当前的整型值。
2. `void set(int newValue)`：设置新的整型值。
3. `int getAndSet(int newValue)`：设置新的整型值并返回旧的值。
4. `int getAndIncrement()`：自增并返回自增前的值。
5. `int getAndDecrement()`：自减并返回自减前的值。
6. `int incrementAndGet()`：自增并返回自增后的值。
7. `int decrementAndGet()`：自减并返回自减后的值。
8. `int addAndGet(int delta)`：将指定值增加给当前值，并返回增加后的值。
9. `int getAndAdd(int delta)`：将指定值增加给当前值，并返回增加前的值。

以下是一个简单的示例，展示如何使用 `AtomicInteger` 进行原子操作：

```java
import java.util.concurrent.atomic.AtomicInteger;

public class AtomicIntegerExample {
    private static AtomicInteger counter = new AtomicInteger(0);

    public static void main(String[] args) {
        // 自增并获取当前值
        int value = counter.incrementAndGet();
        System.out.println("Value after increment: " + value);

        // 自减并获取当前值
        value = counter.decrementAndGet();
        System.out.println("Value after decrement: " + value);

        // 将指定值增加给当前值，并获取增加后的值
        value = counter.addAndGet(5);
        System.out.println("Value after adding 5: " + value);
    }
}
```

需要注意的是，`AtomicInteger` 类提供的操作是原子性的，但不保证多个操作之间的原子性。如果需要对多个操作进行原子性组合，可以使用 `synchronized` 关键字或其他锁机制来保证操作的原子性。

通过使用 `AtomicInteger` 类，可以方便地进行线程安全的整型数据操作，避免了显式的锁机制带来的复杂性和性能开销。

## AtomicLong

生成订单编号     一毫秒内可以接收一万个以内不重复的订单编号

```java
package com.southwind.controller;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.atomic.AtomicLong;
public class Demo {
    private  static AtomicLong seq =   new AtomicLong(0);
    private  static final int max_seq=9999;
    public  static String generateOrderNumber(){
        SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMddHHmmssSSS");
        String timestamp = sdf.format(new Date());
        long sequence = seq.getAndIncrement() % max_seq;
        String orderNumber = timestamp + String.format("%04d",sequence);
        return orderNumber;
    }
}
```

# 异常

Throwable是所有java程序中错误处理的父类，有两种子类ERROR和Exception

Error ：表示 JVM发现的无法预期的错误，属于严重错误，导致无法继续执行，不可以进行捕捉。例如：虚拟机错误（virtualMachineError） ，内存溢出（outofMemoryError）

Exception：表示可恢复的例外，是可以捕捉的，包括 运行时异常，非运行异常

 **运行时异常：** 都是runtimeException的子类，这些异常是不检查异常，程序可以选择捕获处理也可以不处理，一般是逻辑错误引起

**非运行时异常：（编译异常） **除runtimeException以外的异常类，此类异常必须进行处理，如果不处理程序不能编译通过，例如：IOException，SQLException

# Servlet

## Servlet生命周期

 **初始化** ：在这个阶段，Servlet容器创建Servlet的实例，并调用其 init() 方法。该方法用于执行Servlet的一次性初始化任务，初始化的时候初始的是servletConfig配置servlet容器在启动时，在web文件中配置load-on-sartup默认为-1 页面第一次请求的时候进行加载，当为正数时，初始化时间提前到服务器启动时。

 **2. 请求处理** ：一旦Servlet被初始化，它可以处理客户端的请求。对于每个请求，Servlet容器会调用Servlet的
service() 方法，一般不会重写service方法，二十对post和get方法进行操作，然后传递请求和响应对象。Servlet处理请求并生成响应。

 **3. 销毁：** 在某个时刻，Servlet可能会被从服务中移除。在移除之前，Servlet容器会调用Servlet的destroy() 方法。该方法允许Servlet执行任何清理任务或释放在其生命周期中获取的任何资源。

需要注意的是，Servlet容器管理Servlet的生命周期，根据需要创建实例，并在不再需要时销毁它们

什么时候是new初始换的时候

如何测试

Servlet 打印this，在构造方法中随便打印一下

## servlet三大作用域对象

## request

##### 生命周期：

 **创建** ：客户端向服务器发送一次请求,服务器就会创建request对象.

 **销毁** ：服务器对这次请求作出响应后就会销毁request对象.

 **有效** ：仅在当前请求中有效。

## .session

##### 生命周期：

 **创建** ：服务器端第一次调用getSession();(保存在服务器内存中)

 **销毁** ：

1.非正常关闭服务器(正常关闭session会序列化，再次启动服务器session会被反序列化)；

2.session过期了，默认30分钟.

3.手动调用session.invalidate();

 **注意** :关闭浏览器再次访问会找不到session的会话id而不是session被销毁了。session过期了30分钟后自动销毁

 **有效** ：用户打开浏览器会话开始，直到关闭浏览器会话才会结束。一次会话期间只会创建一个session对象

## application

##### 生命周期：

 **创建** ：服务器启动的时候,服务器为每个WEB应用创建一个属于该web项目的对象ServletContext类.

 **销毁** ：服务器关闭或者项目从服务器中移除的时候.

 **有效** ：此信息在整个服务器上被保留。

## 区别

**request:** 每一次请求都是一个新的request对象,如果在web组件之间需要共享同一个请求中的数据,只能使用请求转发.

**session:** 每一次会话都是一个新的session对象,如果需要在一次会话中的多个请求之间需要共享数据,只能使用session.

**application:** 应用对象,Tomcat启动到关闭,表示一个应用,在一个应用中有且只有一个application对象,作用于整个Web应用,可以实现多次会话之间的数据共享.

## JSP中九大内置对象

1. request：表示客户端的请求对象，包含了客户端发送的请求信息，如请求参数、请求头等。
2. response：表示服务器对客户端的响应对象，用于向客户端发送响应信息，如设置响应头、发送响应内容等。
3. session：表示用户会话对象，用于在多个请求之间共享数据，可以存储和获取用户的会话信息。
4. application：表示整个Web应用程序的上下文对象，用于在整个应用程序范围内共享数据，可以存储和获取应用程序级别的信息。
5. out：表示输出流对象，用于向客户端发送内容。
6. pageContext：表示页面上下文对象，包含了当前页面的所有信息，可以获取其他内置对象。
7. config：表示Servlet配置对象，用于获取Servlet的初始化参数。
8. page：表示当前JSP页面本身，可以调用页面的方法。
9. exception：表示异常对象，用于处理页面抛出的异常。

## JavaWeb三大组件

执行顺序：

1. Filter（过滤器）：过滤器在Servlet处理请求之前或之后，对请求和响应进行预处理或后处理。可以有多个过滤器，它们按照在web.xml或注解中定义的顺序依次执行。
2. Servlet（Servlet本身）：Servlet是处理客户端请求的主要组件。一旦过滤器完成处理，请求将传递给Servlet进行处理。
3. Listener（监听器）：监听器用于监听Servlet容器中发生的事件，如ServletContext的创建和销毁、Session的创建和销毁等。它们可以在特定事件发生时执行相应的操作。 这些组件的执行顺序是：过滤器 -> Servlet -> 监听器。

## Jsp标签

1. <% %>：这是最基本的JSP标签，用于嵌入Java代码片段。在这个标签中，可以编写任意有效的Java代码。
2. <%= %>：这个标签用于在页面中输出Java代码的结果。它可以用于显示动态生成的文本或变量的值。

   3.<%@ %>：这个标签用于指定页面的指令，如指定页面的语言、导入Java类、设置页面的缓冲区大小等。

4．<%! %>: 用于声明属性方法类等

5. [jsp:include](jsp:include)：这个标签用于在JSP页面中包含其他的JSP页面或HTML文件。它可以在当前位置动态地插入其他页面的内容。
6. [jsp:forward](jsp:forward)：这个标签用于将请求转发给其他的JSP页面或Servlet。它可以用于实现页面之间的跳转。
   7. [jsp:useBean](jsp:useBean)和[jsp:setProperty](jsp:setProperty)：这些标签用于在JSP页面中创建和操作JavaBean对象。它们可以用于在页面中处理和显示数据。

## Servlet和jsp的区别

**相同点：**

Jsp经过编译后就变成了servlet，jsp本质就是servlet，jvm只能识别java的类，不能识别jsp代码，web容器将jsp的代码编译成jvm能够识别的java类，其实就是当你通过http请求一个jsp页面时，首先Tomcat会调用servelt的service（）方法将jsp变成成为servlet然后执行servlet的代码

**不同点：**

Jsp侧重试图，Servlet主要用于控制逻辑，servlet中没有内有内置对象，

Jsp中的内置对象必须通过httpservletReques对象，httpservletReqspose对象以及Httpservlet得到。

Servlet主要关注业务逻辑的处理和请求响应的生成，通常通过编程方式生成HTML、XML或其他格式的响应。而JSP将Java代码嵌入在HTML页面中，可以更方便地生成动态内容。JSP页面可以看作是Servlet的一种简化形式，它提供了更易于开发和维护的视图层。

# 类加载器

类加载器是jre的一部分，负责动态将类添加到Java虚拟机。

#### 类加载分类

    1、启动类加载器

bootstrap classloader ：加载 `<span lang="EN-US"><JAVA_HOME\>\jre\lib</span>`路径下的核心类库，由于安全考虑只加载包名
java、javax、sun开头的类

    2、扩展类加载器

extension classloader ：加载 `<span lang="EN-US"><JAVA_HOME>\jre\lib\ext</span>`目录下的类库

    3、应用程序类加载器

application classloader：加载 `<span lang="EN-US">classpath</span>``<span>环境变量</span>`所指定的类库，是用户自定义类的默认类加载器。

#### 类加载过程

Java类加载过程主要包括加载、验证、准备、解析和初始化五个阶段。

1. 加载（Loading）：将类的字节码文件加载到内存中，并创建一个对应的Class对象。加载阶段由类加载器完成，类加载器根据类的全限定名查找字节码文件，并将其读取到内存中。
2. 验证（Verification）：验证阶段主要是对**字节码文件的合法性进行验证**，包括文件格式验证、语义验证、字节码验证和符号引用验证等。验证阶段的目的是**确保字节码文件的安全性和正确性**。
3. 准备（Preparation）：在准备阶段，**虚拟机为类的静态变量分配内存，并设置默认初始值**。这些静态变量包括类变量和常量，但不包括实例变量。
4. 解析（Resolution）：解析阶段将**符号引用替换为直接引用**，即将类、方法、字段等符号引用解析为内存中的指针或偏移量。解析阶段主要包**括类解析、接口解析、字段解析和方法解析**等。
5. 初始化（Initialization）：在初始化阶段，**虚拟机对类进行初始化，包括为静态变量赋值和执行静态代码块**。初始化阶段是类加载过程中的最后一步，也是类加载的触发点。

类加载过程是按需加载的，即在需要使用某个类时才会触发该类的加载过程。同时，类加载过程是具有层次性和父子委托性的，即先由父类加载器尝试加载，如果父类加载器无法加载，则由子类加载器尝试加载。

#### 双亲委派机制

是指当一个类加载器收到一个类加载请求时，该类加载器首先会把请求委派给父类加载器。每个类加载器都是如此，只有在父类加载器在自己的搜索范围内找不到指定类时，子类加载器才会尝试自己去加载。

# Cook**和**session**的区别**

1、存储位置不同

Cooke存储在客户端的电脑上，ie是可以从浏览器中找到的

Session是存放在服务器内存中的且session是服务端会话管理技术，但session使用cookie实现的

2、存储容量不同

Cookie保存数据小于等于4k

对于session来说没有上限但是出于服务器性能考虑session也最好不要存放过多数据

3、存储方式不同

Cookie中保存ASSCII字符串，

Session 中能够存储任何数据类型，例如：string，list，map等

4、隐私策略不同

Cookie对客户端是可见的，存在安全性问题

Session存储在服务器上，不存在数据泄露的风险

5、有效期不同

Cookie可以设置有效期，可以认为cookie 是长期有效的

Session是基于sessionId的cookie实现的而sessionId的过期时间默认为-1，只需要关闭窗口session就会失效

6、服务器压力不同

Cookie存储在客户端，不占用服务器资源，适合于并发用户超级多的网站

Session是保存在服务器上的每个用户会产生一个session，多用户条件下会产生非常多的session，造成服务器资源的浪费

7、cookie是使用session实现的。

## 为什么session是用cookie实现的

在基于 Cookie 的会话管理中，服务器在第一次请求时生成一个唯一的 JSession ID，并将该 JSession ID 通过响应的 Set-Cookie 头部发送给客户端，存储在客户端的 Cookie 中。客户端在后续的请求中会自动携带该 Cookie，其中包含了 JSession ID。 当服务器接收到带有 JSession ID 的请求时，它可以根据该 ID 来识别用户，并从服务器端的存储中检索相关的会话数据。这样就能实现在不同请求之间保持用户的状态。

# linux命令

ps -ef | grep [进程关键字] 查看进程 Windows查看端口号【netstat-ano|findstr 端口号】

kill -9 [PID] 杀死进程 windows 杀死进程【taskkill -f

1. ls：列出当前目录的文件和子目录。
2. cd：改变当前工作目录。
3. pwd：显示当前工作目录的路径。
4. mkdir：创建一个新的目录。
5. rm：删除文件或目录。
6. cp：复制文件或目录。
7. mv：移动文件或目录，或者重命名文件或目录。
8. touch：创建一个新的空文件。
9. cat：查看文件内容。
10. grep：在文件中搜索指定的字符串。
11. find：在文件系统中查找文件。
12. chmod：改变文件或目录的权限。
13. chown：改变文件或目录的所有者。
14. chgrp：改变文件或目录的所属组。
15. tar：创建或提取压缩文件。
16. gzip：压缩文件。
17. unzip：解压缩文件。
18. ssh：通过安全的Shell连接到远程主机。
19. scp：通过安全的Shell复制文件到远程主机。
20. ping：测试与远程主机的连接。
21. ifconfig：显示或配置网络接口信息。
22. netstat：显示网络连接和路由表信息。
23. top：显示系统资源的实时使用情况。
24. ps：显示当前运行的进程。
25. kill：终止一个运行的进程。

# Tomcat目录

在Linux中，Tomcat的目录结构通常如下：

 **1. bin 目录** ：包含Tomcat的可执行文件，如启动和关闭脚本。

 **2. conf 目录：** 包含Tomcat的配置文件，如服务器配置文件 server.xml 、全局Web应用程序配置文件 web.xml 等。

 **3. lib 目录** ：包含Tomcat运行所需的库文件。

 **4. logs 目录** ：包含Tomcat的日志文件，如访问日志、错误日志等。

 **5. webapps 目录** ：包含部署在Tomcat中的Web应用程序。每个Web应用程序通常是一个独立的目录，其中包含Web应用程序的相关文件，如HTML、JSP、Servlet、静态资源等。

 **6. work 目录** ：包含Tomcat生成的临时文件和编译后的Servlet类文件。

# 设计模式的原则

设计模式有一些原则，这些原则帮助开发人员更好地理解和应用设计模式。

**开闭原则**（Open-Closed Principle）：对扩展开放，对修改关闭。这意味着在改变一个系统的功能时，应该通过添加新代码来扩展它，而不是修改已有的代码。

单一职责原则（Single Responsibility Principle）：一个类应该只有一个引起它各种行为的原因。这个原则表示应该尽可能地将每个类限制在单一的责任范围内，这有助于提高类的可重用性和可维护性。

**里氏替换原则**（Liskov Substitution Principle）：所有引用父类对象的地方，都能够透明地使用其子类的对象。也就是说，**子类不能改变父类原有的行为和属性，否则会导致代码出现问题。**

**依赖倒置原则**（Dependency Inversion Principle）：**高层模块不应该依赖低层模块，而是应该依赖于抽象。**这个原则强调模块之间的依赖应该基于抽象而不是具体实现。（就比如再controller中注入的是service
而不是serviceImp）

**接口隔离原则**（Interface Segregation Principle）：**多个专门的接口优于一个通用的接口**。这个原则指出，应该尽可能地将接口分离为更小的、更具体的接口，而不是使用通用的、多用途的接口。

**迪米特法则**（Law of Demeter，又称最少知道原则）：**一个对象应该对其他对象尽可能少的了解**。换句话说，一个对象不应该直接调用另一个对象的方法，而是应该通过它们之间的中介对象进行通信。

组合/聚合复用原则（Composite/Aggregate Reuse Principle）：通过组合或聚合关系来实现代码复用。相比于继承，组合/聚合更加灵活，且不会带来额外的耦合关系。

# jdk,jre,jvm是什么及其关系

在Java开发中，JDK（Java Development Kit）、JRE（Java Runtime Environment）和JVM（Java Virtual Machine）是三个重要的概念，它们之间存在紧密的关系。

JDK（Java Development Kit）： JDK是Java开发工具包，它是开发Java应用程序所必需的主要工具集合。**JDK**包括了**Java编译器**（javac）、**Java虚拟机（**JVM）、**Java类库**（Java API）等工具和组件。开发人员可以使用JDK来编写、编译和调试Java程序。

JRE（Java Runtime Environment）： JRE是Java运行时环境，它是在计算机上运行Java程序所必需的环境。**JRE**包括**Java虚拟机**（JVM）和**Java类库**（Java API）。当用户运行Java程序时，JRE会提供必要的运行时支持。

JVM（Java Virtual Machine）： JVM是Java虚拟机，它是Java程序的执行环境。JVM负责将Java字节码（由Java源代码编译而来）解释或编译为本地机器代码，以便计算机可以理解和执行。JVM提供了**内存管理、垃圾回收、安全性和其他运行时特性。**

关系： JDK包含了JRE和一些开发工具（如编译器和调试器）。JDK提供了完整的Java开发环境，可以用于编写、编译和调试Java程序。

JRE是Java程序运行的基本环境，包括Java虚拟机（JVM）和Java类库。JRE没有提供开发工具，只用于执行Java程序。

JVM是Java虚拟机，它是JRE的一部分。JVM负责在运行时执行Java字节码，并提供了内存管理、垃圾回收等功能。

简单来说，JDK是用于开发Java程序的工具包，JRE是用于运行Java程序的运行时环境，而JVM是在运行时执行Java程序的虚拟机

nacos ：8848

nginx：80

tomcat：8080

redis：6379

# VUE

## 前端web项目如何优化

**减少HTTP请求**:合并和压缩CSS和JavaScript文件。使用CSS
Sprites技术可以将多个小图像合并到一张大图像中，然后使用CSS进行定位。

**使用CDN**（内容分发网络）: CDN可以将你的内容分发到全球各地的服务器上，使用户可以从地理位置最近的服务器获取内容，从而加速页面加载速度。

**启用压缩**: 启用Gzip压缩可以显著减少发送到浏览器的文件大小，从而加快页面加载速度。

**缓存利用**：利用浏览器缓存可以减少对同一资源的多次请求，尤其是对于那些不经常更改的资源。

**代码优化**：对JavaScript和CSS进行压缩和混淆，删除不必要的字符和空格，可以减少文件大小。同时，尽量避免使用高开销的JavaScript操作，例如全局变量、复杂的DOM操作等。

**图片优化**：只使用必要的图片，并确保它们被适当地压缩和优化。例如，使用WebP格式可以提供更高的压缩率，同时保持良好的图像质量。

**使用异步加载**：对于JavaScript和CSS，尽可能使用异步加载，以避免阻塞页面的渲染。

使用服务端渲染（SSR）或预渲染：这可以提高首次内容绘制（FCP）和首次有效绘制（FMP）的速度，从而提高SEO和用户体验。

使用性能分析工具：例如Lighthouse，PageSpeed Insights，Chrome DevTools等，它们可以帮助你检查和改善网站性能。

**使用现代前端框架**：React、Vue、Angular等现代前端框架都有各自的性能优化技术，如虚拟DOM、异步组件等。

以上只是一些基本的优化方法，你可以根据具体项目的需要来选择最适合的优化策略。

## 父子组件传值：

### 父组件：

<template>
  <div class="app" style="border: 3px solid #000; margin: 10px">
    我是APP组件
    <!-- 1.父组件向子组件发送数据  2.父组件对子组件的消息进行监听 -->
    <Son :title="myTitle" @changTitle="handleChange"></Son>
  </div>
</template>

<script>
import Son from './components/Son.vue'
export default {
  name: 'App',
  data() {
    return {
      myTitle: '学前端，就来黑马程序员',
    }
  },
  components: {
    Son,
  },
  methods: {
    // 3.提供处理函数，提供逻辑
    handleChange(newTitle) {
      this.myTitle = newTitle
    },
  },
}
</script>

### 子组件：

<template>
  <div class="son" style="border: 3px solid #000; margin: 10px">
    我是Son组件 {{ title }}
    <button @click="changeFn">修改title</button>
  </div>
</template>
<script>
export default {
  name: 'Son-Child',
  props: ['title'],//接收父组件中的值
  methods: {
    changeFn() {
      // 通过this.$emit() 向父组件发送通知
      this.$emit('changTitle','传智教育')
    },
  },
}
</script>

## Vue生命周期

① beforeCreate 在实例初始化之后，数据观测和事件配置之前被调用。
② created 在实例创建完成后被立即调用。
③ beforeMount 在挂载开始之前被调用。
④ mounted el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子。
⑤ beforeUpdate 数据更新时调用，发生在虚拟DOM打补丁之前。
⑥ updated 由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用该钩子。
⑦ beforeDestroy 实例销毁之前调用。
⑧ destroyed 实例销毁后调用

## vue2和vue3的区别

vue2 的响应式原理是利⽤es5 的⼀个 API ，Object.defineProperty()对数据进⾏劫持结合发布订阅模式的⽅式来实现的。
vue3 中使⽤了 es6 的 proxy API 对数据代理，通过 reactive() 函数给每⼀个对象都包⼀层 Proxy，通过 Proxy 监听属性的变化，从⽽ 实现对数据的监控。

## 常见事件

1. @click 点击事件
2. @input 输入事件
3. @submit 提交事件
4. @change 改变事件
5. @mouseover 鼠标移上去事件
6. @mouseout 鼠标移开事件
7. @keydown 按键按下事件
8. @keyup 按键抬起事件
9. @blur 失焦事件
10. @focus 聚焦事件

## vue双向绑定底层的实现原理

1. 数据劫持（Data Observation）：Vue使用了一种名为“响应式”的数据劫持技术。当创建Vue实例时，Vue会递归地遍历数据对象的所有属性，通过Object.defineProperty()方法将每个属性转换为getter和setter。这样一来，当属性值发生变化时，Vue能够捕捉到变化，并通知相关的视图进行更新。
2. 发布-订阅模式（Publish-Subscribe）：Vue使用了一个名为“观察者模式”的发布-订阅模式。在Vue中，每个数据对象都会有一个对应的“依赖收集器”（Dep），它用于收集依赖于该数据对象的所有观察者（Watcher）。当数据对象的属性被访问时，会触发getter方法，这时候会将依赖收集器与当前的观察者关联起来。当数据对象的属性发生变化时，会触发setter方法，这时候会通知依赖收集器，依赖收集器会遍历所有关联的观察者，并通知它们进行更新。

综合起来，当Vue中的数据发生变化时，通过数据劫持和发布-订阅模式，Vue能够自动追踪到变化，并且更新相关的视图。而当用户操作视图时，Vue也能够通过事件监听等机制，将变化反映到数据上，实现双向绑定的效果。

需要注意的是，Vue的双向绑定是基于对象的数据进行的，对于数组的变化，Vue使用了一些特殊的方法进行监听和触发更新，以保证数组的变化也能够被追踪和响应。

## 常用语句的用法

**this.$refs.nextTick用法**：$nextTick等待dom更新之后执行方法中的函数体，vue异步更新DOM

## 怎么获取dom节点

使用$refs属性，需要拿到dom节点中定义ref，然后可以通过this.$refs来拿

## 怎么让css只在当前组件使用

如果一个页面中，两个组件定义过相同的类名，那么就修改一个组件中的样式就影响到另一个组件，为了防止出现这种问题，需要给 `<style>`标签中加入 scoped ，变成 `<style scoped>`，它的原理其实就是给节点上加入了 data-v-xxxxx ，即使两个组件定义过相同类名，也会通过 data-v-xxxxx 进行隔离。

# 索引

**聚簇索引**

Innodb表中，表数据文件本身就是按照b+树组织的一个索引。叶子节点中存放的是表的每一行数据。Innodb通过主键聚集数据，如果没有主键，innodb会选择非空的唯一索引代替。如果没有这样的索引，innodb会隐式定义一个主键作为聚簇索引。

**非聚簇索引：**

非聚簇索引和聚簇索引的区别在于:非聚簇索引中的主键索引和二级索引中的叶子结点存储的都是数据的物理地址，通过索引找到物理位置后，再找到数据。

![descript](file:///C:/Users/90504/AppData/Local/Temp/msohtmlclip1/01/clip_image016.jpg)

主键索引：

 **二级索引** ：

聚簇的在二级索引中，叶子结点不是行记录了，而是主键值。所以使用二级索引查找时，首先在二级索引中找到的是主键值，然后通过主键值找到叶子结点中的数据行。

**索引的优点：**

1数据访问更快

2聚簇索引对于主键排序查找和范围查找更快

缺点：1插入速度严重依赖于插入顺序，对于innodb，一般都会定义一个自增的主键。

2.更新主键的代价很高，每次更新后都需要对索引进行维护

如何建立索引？

create index
index_name on table_name (column_name）

索引不被使用的情况：

JDK 常用命令确实包括了一些 Java 常用命令，但还包括其他一些用于开发和调试的命令。以下是一些常用的 JDK 命令：

1. `javac`：编译 Java 程序。
2. `java`：运行 Java 程序。
3. `jar`：创建和管理 JAR 文件。
4. `javadoc`：生成 API 文档。
5. `jshell`：Java 9 引入的交互式 Shell，用于快速测试和验证代码。
6. `jdeps`：分析类或 JAR 文件的依赖关系。
7. `jlink`：创建自定义运行时镜像。
8. `jimage`：操作和查看镜像文件。

索引列上有函数运算

语句中有隐式转换

表中的数据较小，或者需要查询大部分的数据。数据库自动选择最优，可能不走索引。

语句中有！=可能不走索引

如何查看语句是否走了索引？

在语句上加入关键字explain

# Zookeeper集群

是用来对分布式系统的提供协调服务的，通过zab协议保证分布式事务的一致性。

**Zookeeper ****客户端会随机的链接到 zookeeper 集群中的一个节点，如果是读请求，就直接从当前节点中读取数据；如果是写请求，那么节点就会向 Leader 提交事务，Leader 接收到事务提交，会广播该事务，只要超过半数节点写入成功，该事务就会被提交。**

**Zab协议原理**

Zab协议要求每个 Leader 都要经历三个阶段： **发现，同步，广播** 。

l   **发现** ：要求zookeeper集群必须选举出一个 Leader 进程，同时 Leader 会维护一个 Follower 可用客户端列表。将来客户端可以和这些 Follower节点进行通信。

l   **同步** ：Leader 要负责将本身的数据与
Follower 完成同步，做到多副本存储。这样也是提现了CAP中的高可用和分区容错。Follower将队列中未处理完的请求消费完成后，写入本地事务日志中。

l   **广播** ：Leader 可以接受客户端新的事务请求，将新的请求广播给所有的 Follower

zookeeper集群中有三种角色，分别是leader，follower，observer。

对于客户端的查询操作，可以保证客户端的每次请求所返回的结果都是一样的，对于删除，修改等改变数据的操作，需要leader来协调的。在节点中，只有leader才有修改数据的权利，而follewer节点即使收到了修改数据的请求，也会将请求转发给leader，由leader向所有的follwer广播，让他们执行某一项操作。等超过半数的follwer执行完毕后，leader就会判定此操作已经完成，然后向所有的follwer广播该操作已经生效。

**Zookeeper****选举机制：？？？**

有两种情况，一种是在初始化集群的时候，需要选出来一个leader。一种是leader宕机后，需要选出来一个leader。

**zookeeper****节点的四种状态：**

Leading：表名该节点已经处于领导状态，是master，他有写权限其他没有。

Looking：表名该节点正在寻找leading

Following:表名该节正在跟随领导。可以想leader发送请求，接收leader消息，接收客户端请求。如果是写请求，会交给leader处理，然后响应给客户端。

Observing:和跟随者差不多，但是不参加选举。

**为什么是zookeeper节点是奇数？**

提高容错率，zk容错机制在于，剩下的个数要大于宕机的个数。

# **jvm内存结构**

 **虚拟机栈** ，存储方法，局部变量和对象的引用。每当有一个方法被调用时，该方法就会压栈，当一个方法执行结束后，该方法就会出栈。是线程私有的。

 **堆** ，存储对象实例和数组。是线程之间共享的。

 **方法区：** 存储静态变量，常量，类信息。

 **本地方法栈** ：存储native方法

 **程序计数器：** 存储代码执行的位置

栈是私有的，堆是共享的。在堆中会产生垃圾。所以有垃圾回收机制。垃圾回收机制是分代回收策略。堆内存分为为年轻代和年老代。年轻代分为伊甸园区和幸存区，幸存区有幸存一区和幸存2区。他们之间大小比例是1:1：8。
当一个对象被new出来后，存入到伊甸园区，当**伊甸园区**满了后，进行yong gc，使用复制算法，把幸存下来的对象放进幸存1区中。当对象被回收15次后仍然存活，会将对象放进年老区中。如果年老区内存满了，会执行full gc，对整个堆进行一次垃圾回收，使用的是标记清除算法。如果经过多次垃圾回收后，年轻区和年老区都满了，jvm会报出堆内存溢出异常。

如何解决堆内存溢出异常？。两个方面，首先分析一下代码。看看有没有频繁new对象的代码，造成了频繁垃圾回收。另一方面是调整一下堆内存大小。

**Jvm****调堆参数**

Xmx最大堆内存。Xms最小堆内存 Xmn年轻代大小。年老代大小=堆内存-年轻代大小。

# 数据库

## 数据库三范式

1. 第一范式（1NF）：确保每个表中的每个列都是原子的，即不可再分。每个列中的值应该是单一的，不应该包含多个值或重复的组合。
2. 第二范式（2NF）：在满足1NF的基础上，确保表中的每个非主键列完全依赖于主键，而不是依赖于主键的一部分。这意味着每个非主键列必须与主键形成完整依赖关系，不能存在部分依赖。
3. 第三范式（3NF）：在满足2NF的基础上，确保表中的每个非主键列之间没有传递依赖关系。换句话说，每个非主键列只依赖于主键，而不依赖于其他非主键列。

## 左右连接，内连接

**左连接**的意思是，无论是否符合ON语句后面的表连接条件都会把左边那张表的记录全部查询出来，右边的那张表只匹配符合条件的数据行。

**右连接**则与之相反

**内连接**指的是把表连接时表与表之间匹配的数据行查询出来，就是两张表之间数据行匹配时，要同时满足ON语句后面的条件才行。

# rabbitmq工作模式

一共五种工作模式，前三种有交换机，后两种没有交换机。所谓没有交换机是指没有指定交换机，其实使用的是默认的交换机

**direct直连模式**

![descript](file:///C:/Users/90504/AppData/Local/Temp/msohtmlclip1/01/clip_image033.jpg)

创建消息队列的时候,指定一个路由键（RoutingKey）.当发送者发送消息的时候,指定对应的Key.当Key和消息队列的RoutingKey一致的时候,消息将会被发送到该消息队列中.

如果两个消息队列绑定同一个routingkey时，如何消费？使用轮询

![descript](file:///C:/Users/90504/AppData/Local/Temp/msohtmlclip1/01/clip_image035.jpg)

topic转发信息主要是依据通配符,队列和交换机的绑定主要是依据一种模式(通配符+字符串),而当发送消息的时候,只有指定的Key和该模式相匹配的时候,消息才会被发送到该消息队列中.通配符：* 表示一个词，# 表示零个或多个词

![descript](file:///C:/Users/90504/AppData/Local/Temp/msohtmlclip1/01/clip_image037.jpg)

fanout是路由广播的形式,将会把消息发给绑定它的全部队列。

![descript](file:///C:/Users/90504/AppData/Local/Temp/msohtmlclip1/01/clip_image039.jpg)

消息生产者p将消息放入队列

消费者监听队列,如果队列中有消息,就消费掉,消息被拿走后,自动从队列删除

![descript](file:///C:/Users/90504/AppData/Local/Temp/msohtmlclip1/01/clip_image041.jpg)

生产者将消息放入队列

多个消费者同时监听同一个队列 , 消息如何被消费 ?

C1,C2 共同争抢当前消息队列的内容 , 谁先拿到消息 , 谁来负责消费

rabbitmq回调

# 封装继承多态的关系？

封装：

把一个对象的属性私有化，同时提供对外界访问属性的方法形成类。

继承：

在原有类的基础上，进行更具体更详细的定义。可以从原有类上拿到所有东西（），可以改造原有的类，可以在原有类基础上添加新东西。

多态：

多态是面向对象编程的一个特性，多态就是多种状态。什么是多种状态？不同的子类在继承父类的时候重写了父类的同一个方法，表现出一个方法有多种状态。同时，以多种方法实现接口也是多态。所以能看出，多态是在继承的基础上来的。

# ssm和springboot区别：

springboot

使用springboot我们可以不用或者很少使用配置就可以使项目运行起来。因为Spring框架需要进行大量的配置，Spring Boot而springboot使用习惯优于配置的理念，通过自动配置，让项目设置变得很容易。开发者只需要引入自己需要的第三方库即可。

Sping
Boot的出现是为了使开发者更注重业务的逻辑，简化了对开发环境的配置。

优点：

**帮助我们快速启动一个web项目。**

**继承了原有的spring功能。**

**简化了spring使用流程。**

ssm

spring是一个轻量级的控制反转（IoC）和面向切面（AOP）的容器框架。

SpringMVC分离了控制器、模型对象、分派器以及处理程序对象的角色，这种分离让它们更容易进行定制。

MyBatis是一个支持普通SQL查询，存储过程和高级映射的持久层框架。

ssm优点：

spring ，核心是ioc、aop技术。ioc解耦，使得代码复用，可维护性大幅度提升，aop提供切面编程，同样的增强了生产力。

mybatis的sql可以由开发者去掌控和调优，对sql的控制更加直观。但是在业务场景比较复杂，sql好多联合关联的情况下，mybatis的sql语句编写就比较麻烦了。所以缺点就是对sql不熟悉的开发者就不太友好了。

# maven

maven是一个项目管理工具，他可以管理项目之间的jar包依赖关系。通过配置pom.xml文件可以轻松导入项目需要的jar包。

同时maven还是一个仓库，maven仓库有本地仓库，maven私服仓库和中央仓库。

本地仓库就是当我们导入项目需要的jar包时，maven会自动在本地创建一个仓库，存储我们用过的jar包，下次再使用时可以直接导入，不用下载。

maven私服，公司的仓库，其他人在写好jar包后可以上传到maven私服中，需要的时候任何人可以在私服下载。

maven中央仓库，在下载jar包时，maven首先查找本地仓库有没有，如果没有就去私服找，如果私服没有就去中央仓库找。

# mysql分区：

数据库分区是一种物理数据库设计技术，分区的意思是指将同一表中不同行的记录分配到不同的物理文件中，几个分区就有几个.idb文件。分区的目的是为了在特定的SQL操作中减少数据读写的总量以缩减sql语句的响应时间，同时对于应用来说分区完全是透明的。

MYSQL的分区主要有两种形式：水平分区和垂直分区。

水平分区是根据表的行进行分区，也就是把一张大表分成多个小表。原表有十万行数据，分表分两万行一个小表。

水平分区一定要通过某个属性列来分割。比如一张包括每年的历史大事的数据表，数据都存在一张表中，可以按年份字段进行分区，从而让每个分区的数据量适中，避免全表过大。

垂直分区：

对表进行垂直划分来减少原表的长度。比如说原来一张表中与15个列，通过垂直分区，把15个列分为5个列一张表。

实现分区的四种算法：

 **range** ：根据范围分区

partition by range(salary)

(partition p1 values less than ( **1000** ),

partition p2 values less than ( **2000** ));

 **list** ：罗列出值，根据值进行分区：

partition by list(

    partition name1 values in(1,3,5),

    partition name2 values in(2,4,6),..

)

 **hash**  **：** 指定要分几个区，指定根据那个列值hash，至于如何hash是mysql自动完成的

partition by hash( **salary** )

partitions  **4** ;

 **key**  **：** 跟hash差不多，key也是使用hash，使用是mysql自己的hash函数。hash可以自己指定一种hash函数**。**

partition by key(birthdate)

partitions  **4** ;

# Tomcat优化：

内存优化

-Xms：Java虚拟机初始化时堆的最小内存，一般与 Xmx配置为相同值，这样的好处是GC不必再为扩展内存空间而消耗性能；

    -Xmx：Java虚拟机可使用堆的最大内存；

    -XX:PermSize：Java虚拟机永久代大小；

    -XX:MaxPermSize：Java虚拟机永久代大小最大值；

线程优化：在Connector中设置最大线程数。tomcat默认线程数是200

tomcat做负载均衡

# 什么是微服务?

就是根据业务拆分成一个个的服务，彻底解耦。每一个服务提供单独的业务功能，一个服务做一件事。

# 谈谈VUE

**1.vue****父组件向子组件传递数据？**

答：通过props

 **2.** **子组件像父组件传递事件？**

答：$emit方法

 **3.`<keep-alive></keep-alive>`** **的作用是什么?**

答:keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。

 **4.** **说出几种vue当中的指令和它的用法？**

答：v-model双向数据绑定；

v-for循环；

v-if v-show 显示与隐藏；

v-on事件；v-once:
只绑定一次。

v-bind绑定一个value属性；

**5.axios****及安装?**

答：请求后台资源的模块。npm install
axios --save装好，

js中使用import进来，然后.get或.post。返回在.then函数中如果成功，失败则是在.catch函数中。

**其他：**

4. final 在 java 中有什么作用？

final 修饰的类叫最终类，该类不能被继承。

final 修饰的方法不能被重写。

final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。

如何决定使用 HashMap 还是 TreeMap？

对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。

1、 HashMap和Hashtable是Map接口下的两个实现类，因为Map对象是键值对的，所以此两类也是键值对的。

2、 HashMap是线程非安全的，Hashtable是线程安全的，所以HashMap的效率高于Hashtable。

3、 HashMap允许键或值为null，键最多只可以有一个为null，值不受限制。而Hashtable键或值都不许为null。

注意：Hashtable中的“t”是小写的。

ArrayList和Vector使用数组存储元素；LinkedList使用链表存储元素

2. ArrayList和Vector插入删除数据时，需要搬运数据，效率较差；LinkedList使用链表，不需要搬运数据，效率高
3. ArrayList和Vectory查询时，按数组下标查询，不需要遍历，效率高；LinkedList需要遍历，查询效率底
