# 1、 vue组件中data为什么必须是一个函数？

因为JavaScript 的特性所导致，在 component 中，data 必须以函数的形式存在，不可以是对象.
组建中的 data 写成一个函数，数据以函数返回值的形式定义，这样每次复用组件的时候，都会返回一份新的 data，相当于每个组件实例都有自己私有的数据空间，它们只负责各自维护的数据，不会造成混乱。而单纯的写成对象形式，就是所有的组件实例共用了一个 data，这样改一个全都改了

# 2、 用户权限校验

1. 定义角色和权限：首先，需要定义用户角色和每个角色对应的权限。角色可以根据用户的身份、职位等属性进行分类，而权限表示用户在系统中可以执行的操作或访问的资源。
2. 用户登录：jwt，用户在访问系统时，需要提供凭证（如用户名和密码）进行身份认证，登录成功后会生成一个会话标识（如令牌或Session ID）。
3. 分配角色和权限：在用户登录成功后，根据用户的身份，可以将相应的角色和权限关联到用户上。这样系统就知道了该用户的角色和权限。
4. 权限校验：在需要进行权限校验的地方，如路由拦截、接口请求等，可以对用户的权限进行校验。具体校验的方式可以根据实际情况选择，如：
   - 在前端实现：前端可以保存用户的角色和权限信息，然后在访问受限资源之前，对用户的角色和权限进行验证。如果验证不通过，可以跳转到登录页或提示用户无权访问。
   - 在后端实现：后端可以在接收到请求后通过会话标识或其他方式获取用户的角色和权限信息，然后在访问受限资源之前，对用户的角色和权限进行验证。如果验证不通过，可以返回相应的错误码或消息。

# 3、 性能优化

## 打包

1. 代码拆分：将代码拆分为多个模块，按需加载。这样可以减小初始加载的文件大小，提高页面的加载速度。可以使用Webpack的代码分割功能或动态导入来实现。
2. 按需加载：使用Webpack中的动态导入（dynamic import）或路由懒加载（route-based code splitting），只在需要时才加载特定的模块，避免一次性加载过多的资源。登录和首页不需要
3. 压缩和混淆：使用Webpack的压缩插件（如 `TerserPlugin`）对打包后的文件进行压缩和混淆，减小文件大小，并提高加载速度。
4. Tree Shaking：通过Webpack的Tree Shaking机制，将未使用的代码从最终的包中删除，减小文件大小。
5. 分包策略：根据业务需求和使用频率，将各个模块进行合理的拆分和分包，减小初始加载的文件大小。
   一个小程序分四个包(一个包40M)
6. 使用CDN：将一些第三方库或公共资源上传到CDN，通过CDN加载，可以减轻服务器压力，提高资源加载速度。上传到云服务器上
7. 缓存管理：为文件添加合适的缓存头（如设置文件的HTTP缓存头），利用浏览器缓存，减少不必要的请求。

## 运行

1. 减少重绘和重排：尽量避免频繁改变DOM、样式等操作，会引起页面的重绘和重排，影响性能。合并和最小化DOM操作，使用CSS动画或transform来提高动画性能。
2. 虚拟列表和虚拟滚动：针对大数据列表和长列表，使用虚拟列表或虚拟滚动技术，只渲染可见部分，减少渲染的DOM数量，提高列表的性能。
3. 事件优化：避免绑定大量的事件监听器，使用事件委托来管理事件，减少内存占用，提高事件处理的效率。
4. 性能监测和分析：使用工具（如Chrome DevTools）或服务（如Google PageSpeed Insights）来监测和分析应用的性能，找出瓶颈并进行调整和优化。
5. 避免内存泄漏：及时释放不再使用的资源和引用，避免内存泄漏，影响应用的性能和稳定性。
6. 异步操作和并行处理：将耗时的操作（如网络请求、计算等）放入异步任务中，避免阻塞主线程，提高应用的响应速度和用户体验。
7. 优化图片和资源：使用适当的图像格式、压缩和缩放图像，减小文件大小。合并并压缩CSS、JS等静态资源，减少请求次数，提高加载速度。
8. 利用浏览器缓存：合理设置响应头，利用浏览器缓存静态资源，减少重复的请求，提高加载速度。

# 4、 Vue数据响应式：

Vue 的响应式系统是其核心特性之一，它使得数据和视图保持同步，并能够自动响应数据的变化而更新视图。Vue 使用了一种名为“响应式”的机制来实现这个特性，主要是通过数据劫持和依赖追踪来实现的。
以下是 Vue 的响应式系统的基本原理
数据劫持 (Data Observation)
Vue 在初始化时会对数据对象进行递归遍历，把每个属性转换为 getter/setter，并且添加-个名为“Dep”的依赖追踪器对象。这样一来，当数据属性被读取或修改时，Vue 就能知道并
做出相应的反应。

依赖追踪 (Dependency Tracking)在模板中，Vue 的模板编译器会分析模板中的数据绑定，并在相应的数据属性上添加监听器。这些监听器会建立一个“依赖追踪”关系，将视图和数据的关系建立起来。当数据属性的值发生变化时，依赖追踪器会通知相关的监听器，从而触发视图的更新。自动更新视图:
-旦数据发生变化，相应的视图会自动更新。这是因为 Vue 使用了虚拟 DOM技术，它将变更前后的模板进行比较，只更新变化的部分，而不是整个页面。这样可以大大提高页面更新的性能。
异步更新 (Batching)
为了优化性能，Vue 会将数据的变更收集起来，然后在下一个事件循环中统一执行视图的更新。这样可以避免不必要的重复渲染，提高性能。

# 5、 什么是虚拟dom：

虚拟dom本质上就是一个普通的JS对象，为了获取页面的更新，vue先从内部生成一个类似真实dom的虚拟dom树，在挂载对象的时候，生成新的虚拟dom树，新树与旧树进行对比

# 6、 什么是Spa：

单页面应用程序，是一种Web应用程序的架构模式，它通过动态更新页面的局部内容来提供更流畅的用户体验，而不是每次加载整个页面。

# 7、 单页面性能优化

1. 代码拆分：将应用代码划分为多个模块，按需加载。这样可以减少初始加载时间，只加载当前页面所需的代码。
2. 路由懒加载：使用路由懒加载的方式，按需加载每个页面的组件和相关代码。这样可以减少首次加载的大小，提高页面的加载速度。
3. 图片优化：缩小图片尺寸，压缩图片文件大小。可以使用工具压缩图片，或使用适当的图片格式，如使用WebP格式等。
4. 缓存策略：合理使用浏览器缓存，并为静态资源设置适当的缓存策略（如设置文件的HTTP缓存头）。
5. 资源合并和压缩：减少HTTP请求，将多个CSS文件和JS文件合并为一个文件，并对文件进行压缩，以减小文件大小。
6. 预加载和预渲染：使用 `<link rel="preload">`标签预加载下一个页面所需的资源，或使用预渲染技术提前生成下一个页面的HTML。
7. 代码优化：优化JavaScript代码，减少不必要的重绘和重排，减少DOM操作的次数，尽量减少不必要的计算和网络请求。
8. 按需渲染：仅渲染当前页面可见的内容，延迟加载不可见区域的内容，以提高页面的加载速度。
9. 服务端渲染（SSR）：对于需要SEO和首屏加载速度较高的页面，可以考虑使用服务端渲染来提前生成HTML并直接返回给浏览器。
10. 移除不必要的依赖和代码：检查并移除不使用的依赖库和代码，减小应用的整体体积。

# 8、 vue 中 computed和watch的区别?

computed 是计算属性, 可以根据data 中的数据成员,动态计算出一个 新的数据成员(这个数据成员在data 中并不存在), 计算属性的函数必 须有返回值; watch 是监视器, 可以监视 data 中某一个数据成员的改 变或路由中的某些属性的改变, 可以根据这个改变, 做一些其他操作 (不仅仅局限于更新其他相关数据).

用法：

# 9、 什么是vuex

Vuex是Vue.js的官方状态管理库，用于管理Vue.js应用程序中的共享状态。它可以帮助我们在多个组件之间共享和管理状态，并且提供了一种可预测和可维护的状态管理方案。

Vuex包含以下核心概念：

1. State（状态）: 用于存储共享的状态数据。
2. Getters（计算属性）: 用于从状态中派生出新的状态，类似于Vue组件中的计算属性。
3. Mutations（变更）: 用于修改状态，必须是同步的操作。
4. Actions（动作）: 用于处理异步操作或触发多个Mutations。
5. Modules（模块）: 可以将Vuex的状态树拆分成多个模块，每个模块包含自己的state、getters、mutations和actions。

# 10、 url组成：

1. 协议（Protocol）：URL的协议部分指定了用于访问资源的协议，例如：`http://`、`https://`、`ftp://`等。
2. 域名（Domain Name）：域名是由一系列标签组成的字符串，用于标识网络上的特定主机或服务。例如：`www.example.com`。
3. 端口（Port）：端口是一个数字，用于标识特定的网络服务。如果未明确指定端口，将使用协议的默认端口。例如，HTTP默认使用端口80，HTTPS默认使用端口443。
4. 路径（Path）：路径指定了服务器上资源的位置。它是一个由斜杠（/）分隔的字符串，用于指示资源的层次结构。例如：`/products/12345`。
5. 查询参数（Query Parameters）：查询参数附加在URL的路径后面，并以问号（?）开头。它们用于向服务器传递额外的参数，以影响请求的行为。参数由键值对组成，多个参数之间使用 ampersand（&）分隔。例如：`?category=books&page=2`。
6. 锚点（Fragment Identifier）：锚点是一个由井号（#）开头的字符串，用于在资源中定位特定的片段。它通常用于在网页中跳转到特定的位置。例如：`#section1`。

下面是一个示例URL，展示了这些组成部分的结合：

```
https://www.example.com/products/12345?category=books&page=2#section1
```

在实际应用中，URL还可以包含其他可选的组成部分，例如用户名、密码和子域等。根据具体的协议和应用场景，URL的组成可能会有所不同。

# 11、 http协议报文结构

1. 请求报文（Request Message）：
   - 请求行（Request Line）：包括请求方法、请求目标（URL或URI）和HTTP版本。
   - 请求头部（Request Header）：包括请求的相关信息，如请求的主机、用户代理、接受的内容类型等。
   - 空行（Blank Line）：请求头部与请求主体之间需要一个空行来分隔。
   - 请求主体（Request Body）：可选字段，包含请求所带的数据，一般在POST、PUT等方法中使用。
2. 响应报文（Response Message）：
   - 状态行（Status Line）：包括HTTP版本、状态码和对应的状态消息。
   - 响应头部（Response Header）：包括响应的相关信息，如服务器类型、内容类型、响应时间等。
   - 空行（Blank Line）：响应头部与响应主体之间需要一个空行来分隔。
   - 响应主体（Response Body）：可选字段，包含响应的数据，一般在GET、POST等方法中返回。

# 12、什么是MVVM

模型（Model）指的是后端传递的数据。视图(View)指的是所看到的页面。视图模型(ViewModel)是mvvm模式的核心，它是连接view和model的桥梁。它有两个方向：一是将模型（Model）转化成视图(View)，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。二是将视图(View)转化成模型(Model)，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。这两个方向都实现的，我们称之为数据的双向绑定。

# 13、 请求头的请求方式

Content-Type是HTTP请求头中的一个字段，用于指定请求或响应中包含的实体主体的媒体类型。

在请求中，Content-Type用于告知服务器请求正文的媒体类型。常见的Content-Type值有：

- application/json：用于指定请求正文为JSON格式
- application/x-www-form-urlencoded：用于指定请求正文为表单数据形式
- multipart/form-data：用于指定请求正文为多部分表单数据形式（通常用于文件上传）
- text/plain：用于指定请求正文为纯文本形式
- application/xml：用于指定请求正文为XML格式

在响应中，Content-Type用于指定响应正文的媒体类型。常见的Content-Type值有：

- text/html：用于指定响应正文为HTML格式
- application/json：用于指定响应正文为JSON格式
- image/jpeg：用于指定响应正文为JPEG图片格式
- application/pdf：用于指定响应正文为PDF文档格式

# 14、vue双向绑定流程

1、实现一个[监听器](https://so.csdn.net/so/search?q=监听器&spm=1001.2101.3001.7020) `Observer` ，用来劫持并监听所有属性，如果属性发生变化，就通知订阅者；

2、实现一个订阅器 `Dep`，用来收集订阅者，对监听器 `Observer` 和 订阅者 `Watcher` 进行统一管理；

3、实现一个订阅者 `Watcher`，可以收到属性的变化通知并执行相应的方法，从而更新视图；

4、实现一个解析器 `Compile`，可以解析每个节点的相关指令，对模板数据和订阅器进行初始化。

# 15、vue生命周期

  创建前后：

beforeCreate 阶段：初始化数据还未开始，也就是说不能访问到data、computed、watch、methods上的方法和数据。
created 阶段：vue 实例的数据 data 有了， 渲染得节点还未挂载到 DOM，所以不能访问到 $el属性。（vue的实例挂载元素el）
 挂载前后：

在 beforeMount 阶段：Vue开始解析模板，生成虚拟DOM存在内存中，还没有把虚拟DOM转换成真实DOM，插入页面中。所以网页不能显示解析好的内容。
在 mounted 阶段：vue 实例挂载完后,将内存中的虚拟DOM转为真实DOM，真实DOM插入页面   （一般在这个阶段进行：开启定时器，发送网络请求，订阅消息，绑定自定义事件）
更新前后：

在beforeUpdate阶段：响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 DOM 还没有被渲染（数据是新的，但页面是旧的，页面和数据没保持同步呢）。
在updated阶段：更新完毕
销毁先后：

 在beforeDestory阶段：这个阶段一般进行关闭定时器，取消订阅消息，解绑自定义事件
在destoryed阶段：Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。

# 16、前后端数据的请求方式

1. HTTP请求：前端通过使用HTTP协议向后端发送请求，后端处理请求并返回相应的数据。常见的HTTP请求方式包括：
   - GET：用于获取数据，将数据放在URL的查询参数中。
   - POST：用于提交数据，将数据放在请求正文中。
   - PUT：用于更新数据，将数据放在请求正文中，通常会指定待更新数据的唯一标识符。
   - DELETE：用于删除数据，将待删除数据的唯一标识符放在URL中。
2. AJAX：AJAX是通过JavaScript异步发送HTTP请求的技术。前端使用XMLHttpRequest对象或Fetch API发起HTTP请求，而不需要刷新整个页面。通过AJAX，前端可以异步获取数据并动态更新网页内容。
3. WebSocket：WebSocket是一种持久化的通信协议，它建立在HTTP基础上，实现了双向通信。前端通过WebSocket与后端建立连接，并可在连接保持的情况下发送和接收数据。WebSocket适用于需要实时更新数据的应用，如聊天应用、实时通知等。

# 17、动态路由

定义路由表: 首先，在Vue Router的配置中定义路由表，包括需要动态传递的参数。可以使用冒号(:)来定义动态参数。例如：
const routes = [
  { path: '/user/:id', component: UserProfile }
]创建组件: 根据需要，创建对应的组件，用于显示根据动态参数加载的内容。例如，在上述示例中，我们可以创建一个名为UserProfile的组件。
// UserProfile.vue
`<template>`

<div>
    <h1>User Profile</h1>
    <p>User ID: {{ userId }}</p >
  </div>
</template>

<script>
export default {
  data() {
    return {
      userId: null
    }
  },
  mounted() {
    this.userId = this.$route.params.id;
    // 根据userId加载对应用户的信息
  }
}
</script>使用路由参数: 在需要使用动态路由的地方，使用路由的名称和要传递的参数来构建动态链接。使用<router-link>来生成链接。例如，在其他组件中，可以这样使用动态路由链接：

`<router-link :to="'/user/' + user.id">`View Profile`</router-link>`监听路由变化: 如果需要在动态路由参数发生变化时执行某些操作（例如重新加载数据），可以使用Vue Router提供的导航守卫功能来监听路由的变化。导航守卫可以在路由切换前、切换后或任意导航触发时执行相应的逻辑。详情请参考Vue Router的导航守卫文档。

# 18、vue3.0响应原理

Vue 3.0的响应式原理通过基于Proxy的代理对象和依赖追踪来实现。Proxy在拦截对代理对象的访问和修改时，实现了对依赖的追踪和通知。这种基于Proxy的响应式系统在性能和功能方面有着明显的提升，使得Vue 3.0的响应式能力更加灵活和高效。

# 19、$el和v-el

在Vue.js中，`$el`和 `v-el`都与操作DOM元素相关，但用法和作用略有区别。

1. `$el`：

   - `$el`是Vue组件实例的一个属性，用于访问实例所关联的根DOM元素。
   - 在组件实例化之后，可以通过 `this.$el`来访问组件的根DOM元素。
   - 通过 `$el`可以获取该组件生成的HTML元素，也可以操作DOM元素的属性和方法。

   例如，可以通过 `this.$el.style`来访问组件根元素的样式，或者通过 `this.$el.querySelector(selector)`来选择组件根元素中的子元素。

   ```
   export default {
     mounted() {
       console.log(this.$el) // 访问组件的根DOM元素
       console.log(this.$el.style) // 访问根DOM元素的样式
       console.log(this.$el.querySelector('.child-element')) // 选择根DOM元素中的子元素
     }
   }
   ```

   注意，使用 `$el`直接操作DOM元素可能会违反Vue的响应式规则，因此在大多数情况下，推荐使用Vue的数据驱动方式来操作DOM。
2. `v-el`（已弃用）：

   - `v-el`是Vue.js 2.x版本中的一个自定义指令，用于在组件实例中注册一个DOM元素的引用。
   - `v-el`指令指定一个名称，该名称将与一个引用元素关联。组件实例可以使用这个名称来访问引用的DOM元素。
   - 但是，从Vue.js 2.0起，`v-el`指令已经被废弃，不再建议使用，并被新的 `ref`属性代替。因此，不推荐在Vue.js 2.x中使用 `v-el`指令。

   例如，在Vue.js 1.x版本中，可以使用 `v-el`指令为DOM元素注册引用，并在组件中使用该引用：

   ```
   <template>
     <div>
       <button v-el:myButton @click="handleClick">Click me</button>
     </div>
   </template>

   <script>
   export default {
     methods: {
       handleClick() {
         console.log(this.$els.myButton) // 通过引用访问DOM元素
       }
     }
   }
   </script>
   ```

   在Vue.js 2.x版本中，不再推荐使用 `v-el`指令，而是推荐使用 `ref`属性来获取DOM元素的引用。

总结：`$el`是Vue组件实例的一个属性，用于访问组件的根DOM元素；而 `v-el`是Vue.js 1.x版本中的指令，用于在组件中注册DOM元素的引用，但在Vue.js 2.x版本中已被废弃，不推荐使用。在Vue.js 2.x中，应该使用 `ref`属性来获取DOM元素的引用。

# 20、ref

> 1、ref 加在普通的元素上，用 this.$refs.name 获取到的是dom元素
>
> 2、ref 加在子组件上，用 this.$refs.name 获取到的是组件实例，可以使用组件的所有方法。
>
> 注意：
>
> ref 需要在dom 渲染完成后才会有，在使用的时候确保dom已经渲染完成。
>
> 比如在生命周期 mounted(){ } 钩子中调用，或者在 this.$nextTick(()=>{ }) 中调用。

# 21、SSR

SSR（Server-Side Rendering，服务端渲染）是一种在服务器端生成HTML页面的技术，与传统的前端渲染（客户端渲染）不同。在传统的前端渲染中，浏览器会下载初始的HTML页面，然后通过执行JavaScript来动态生成并填充页面内容。

SSR的优势包括：

1. 更好的SEO（Search Engine Optimization，搜索引擎优化）：搜索引擎能够直接读取到渲染好的HTML内容，有利于网页的索引和排名。
2. 更快的首屏加载速度：客户端不需要再等待JavaScript代码的执行，直接展示已渲染好的HTML页面，提供更好的用户体验。
3. 更好的可访问性：对于某些搜索引擎爬虫、低端设备或不支持JavaScript的浏览器，SSR页面能够提供基本的可访问性。
4. 渐进增强：通过在服务器端生成HTML页面，可以确保即使在客户端JavaScript出现问题时，用户仍然能够访问到基本的页面内容。
