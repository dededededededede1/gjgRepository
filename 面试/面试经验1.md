# 1、 vue组件中data为什么必须是一个函数？

因为JavaScript 的特性所导致，在 component 中，data 必须以函数的形式存在，不可以是对象.
组建中的 data 写成一个函数，数据以函数返回值的形式定义，这样每次复用组件的时候，都会返回一份新的 data，相当于每个组件实例都有自己私有的数据空间，它们只负责各自维护的数据，不会造成混乱。而单纯的写成对象形式，就是所有的组件实例共用了一个 data，这样改一个全都改了

# 2、 用户权限校验

1. 定义角色和权限：首先，需要定义用户角色和每个角色对应的权限。角色可以根据用户的身份、职位等属性进行分类，而权限表示用户在系统中可以执行的操作或访问的资源。
2. 用户登录：用户在访问系统时，需要提供凭证（如用户名和密码）进行身份认证，登录成功后会生成一个会话标识（如令牌或Session ID）。
3. 分配角色和权限：在用户登录成功后，根据用户的身份，可以将相应的角色和权限关联到用户上。这样系统就知道了该用户的角色和权限。
4. 权限校验：在需要进行权限校验的地方，如路由拦截、接口请求等，可以对用户的权限进行校验。具体校验的方式可以根据实际情况选择，如：
   - 在前端实现：前端可以保存用户的角色和权限信息，然后在访问受限资源之前，对用户的角色和权限进行验证。如果验证不通过，可以跳转到登录页或提示用户无权访问。
   - 在后端实现：后端可以在接收到请求后通过会话标识或其他方式获取用户的角色和权限信息，然后在访问受限资源之前，对用户的角色和权限进行验证。如果验证不通过，可以返回相应的错误码或消息。

# 3、 性能优化

## 打包

1. 代码拆分：将代码拆分为多个模块，按需加载。这样可以减小初始加载的文件大小，提高页面的加载速度。可以使用Webpack的代码分割功能或动态导入来实现。
2. 按需加载：使用Webpack中的动态导入（dynamic import）或路由懒加载（route-based code splitting），只在需要时才加载特定的模块，避免一次性加载过多的资源。
3. 压缩和混淆：使用Webpack的压缩插件（如`TerserPlugin`）对打包后的文件进行压缩和混淆，减小文件大小，并提高加载速度。
4. Tree Shaking：通过Webpack的Tree Shaking机制，将未使用的代码从最终的包中删除，减小文件大小。
5. 分包策略：根据业务需求和使用频率，将各个模块进行合理的拆分和分包，减小初始加载的文件大小。
6. 使用CDN：将一些第三方库或公共资源上传到CDN，通过CDN加载，可以减轻服务器压力，提高资源加载速度。
7. 缓存管理：为文件添加合适的缓存头（如设置文件的HTTP缓存头），利用浏览器缓存，减少不必要的请求。

## 运行

1. 减少重绘和重排：尽量避免频繁改变DOM、样式等操作，会引起页面的重绘和重排，影响性能。合并和最小化DOM操作，使用CSS动画或transform来提高动画性能。
2. 虚拟列表和虚拟滚动：针对大数据列表和长列表，使用虚拟列表或虚拟滚动技术，只渲染可见部分，减少渲染的DOM数量，提高列表的性能。
3. 事件优化：避免绑定大量的事件监听器，使用事件委托来管理事件，减少内存占用，提高事件处理的效率。
4. 性能监测和分析：使用工具（如Chrome DevTools）或服务（如Google PageSpeed Insights）来监测和分析应用的性能，找出瓶颈并进行调整和优化。
5. 避免内存泄漏：及时释放不再使用的资源和引用，避免内存泄漏，影响应用的性能和稳定性。
6. 异步操作和并行处理：将耗时的操作（如网络请求、计算等）放入异步任务中，避免阻塞主线程，提高应用的响应速度和用户体验。
7. 优化图片和资源：使用适当的图像格式、压缩和缩放图像，减小文件大小。合并并压缩CSS、JS等静态资源，减少请求次数，提高加载速度。
8. 利用浏览器缓存：合理设置响应头，利用浏览器缓存静态资源，减少重复的请求，提高加载速度。

# 4、 Vue数据响应式：

Vue 的响应式系统是其核心特性之一，它使得数据和视图保持同步，并能够自动响应数据的变化而更新视图。Vue 使用了一种名为“响应式”的机制来实现这个特性，主要是通过数据劫持和依赖追踪来实现的。
以下是 Vue 的响应式系统的基本原理
数据劫持 (Data Observation)
Vue 在初始化时会对数据对象进行递归遍历，把每个属性转换为 getter/setter，并且添加-个名为“Dep”的依赖追踪器对象。这样一来，当数据属性被读取或修改时，Vue 就能知道并
做出相应的反应。依赖追踪 (Dependency Tracking)在模板中，Vue 的模板编译器会分析模板中的数据绑定，并在相应的数据属性上添加监听器。这些监听器会建立一个“依赖追踪”关系，将视图和数据的关系建立起来。当数据属性的值发生变化时，依赖追踪器会通知相关的监听器，从而触发视图的更新。自动更新视图:
-旦数据发生变化，相应的视图会自动更新。这是因为 Vue 使用了虚拟 DOM技术，它将变更前后的模板进行比较，只更新变化的部分，而不是整个页面。这样可以大大提高页面更新的性能。
异步更新 (Batching)
为了优化性能，Vue 会将数据的变更收集起来，然后在下一个事件循环中统一执行视图的更新。这样可以避免不必要的重复渲染，提高性能。

# 5、 什么是虚拟dom：

虚拟dom本质上就是一个普通的JS对象，为了获取页面的更新，vue先从内部生成一个类似真实dom的虚拟dom树，在挂载对象的时候，生成新的虚拟dom树，新树与旧树进行对比

# 6、 什么是Spa：

单页面应用程序，是一种Web应用程序的架构模式，它通过动态更新页面的局部内容来提供更流畅的用户体验，而不是每次加载整个页面。

# 7、 单页面性能优化

1. 代码拆分：将应用代码划分为多个模块，按需加载。这样可以减少初始加载时间，只加载当前页面所需的代码。
2. 路由懒加载：使用路由懒加载的方式，按需加载每个页面的组件和相关代码。这样可以减少首次加载的大小，提高页面的加载速度。
3. 图片优化：缩小图片尺寸，压缩图片文件大小。可以使用工具压缩图片，或使用适当的图片格式，如使用WebP格式等。
4. 缓存策略：合理使用浏览器缓存，并为静态资源设置适当的缓存策略（如设置文件的HTTP缓存头）。
5. 资源合并和压缩：减少HTTP请求，将多个CSS文件和JS文件合并为一个文件，并对文件进行压缩，以减小文件大小。
6. 预加载和预渲染：使用`<link rel="preload">`标签预加载下一个页面所需的资源，或使用预渲染技术提前生成下一个页面的HTML。
7. 代码优化：优化JavaScript代码，减少不必要的重绘和重排，减少DOM操作的次数，尽量减少不必要的计算和网络请求。
8. 按需渲染：仅渲染当前页面可见的内容，延迟加载不可见区域的内容，以提高页面的加载速度。
9. 服务端渲染（SSR）：对于需要SEO和首屏加载速度较高的页面，可以考虑使用服务端渲染来提前生成HTML并直接返回给浏览器。
10. 移除不必要的依赖和代码：检查并移除不使用的依赖库和代码，减小应用的整体体积。

# 8、 vue 中 computed和watch的区别?

computed 是计算属性, 可以根据data 中的数据成员,动态计算出一个 新的数据成员(这个数据成员在data 中并不存在), 计算属性的函数必 须有返回值; watch 是监视器, 可以监视 data 中某一个数据成员的改 变或路由中的某些属性的改变, 可以根据这个改变, 做一些其他操作 (不仅仅局限于更新其他相关数据).

用法：

# 9、 什么是vuex

Vuex是Vue.js的官方状态管理库，用于管理Vue.js应用程序中的共享状态。它可以帮助我们在多个组件之间共享和管理状态，并且提供了一种可预测和可维护的状态管理方案。

Vuex包含以下核心概念：

1. State（状态）: 用于存储共享的状态数据。
2. Getters（计算属性）: 用于从状态中派生出新的状态，类似于Vue组件中的计算属性。
3. Mutations（变更）: 用于修改状态，必须是同步的操作。
4. Actions（动作）: 用于处理异步操作或触发多个Mutations。
5. Modules（模块）: 可以将Vuex的状态树拆分成多个模块，每个模块包含自己的state、getters、mutations和actions。

# 10、 url组成：

1. 协议（Protocol）：URL的协议部分指定了用于访问资源的协议，例如：`http://`、`https://`、`ftp://`等。
2. 域名（Domain Name）：域名是由一系列标签组成的字符串，用于标识网络上的特定主机或服务。例如：`www.example.com`。
3. 端口（Port）：端口是一个数字，用于标识特定的网络服务。如果未明确指定端口，将使用协议的默认端口。例如，HTTP默认使用端口80，HTTPS默认使用端口443。
4. 路径（Path）：路径指定了服务器上资源的位置。它是一个由斜杠（/）分隔的字符串，用于指示资源的层次结构。例如：`/products/12345`。
5. 查询参数（Query Parameters）：查询参数附加在URL的路径后面，并以问号（?）开头。它们用于向服务器传递额外的参数，以影响请求的行为。参数由键值对组成，多个参数之间使用 ampersand（&）分隔。例如：`?category=books&page=2`。
6. 锚点（Fragment Identifier）：锚点是一个由井号（#）开头的字符串，用于在资源中定位特定的片段。它通常用于在网页中跳转到特定的位置。例如：`#section1`。

下面是一个示例URL，展示了这些组成部分的结合：

```
https://www.example.com:8080/products/12345?category=books&page=2#section1
```

在实际应用中，URL还可以包含其他可选的组成部分，例如用户名、密码和子域等。根据具体的协议和应用场景，URL的组成可能会有所不同。

 

# 11、 http协议报文结构

1. 请求报文（Request Message）：
   - 请求行（Request Line）：包括请求方法、请求目标（URL或URI）和HTTP版本。
   - 请求头部（Request Header）：包括请求的相关信息，如请求的主机、用户代理、接受的内容类型等。
   - 空行（Blank Line）：请求头部与请求主体之间需要一个空行来分隔。
   - 请求主体（Request Body）：可选字段，包含请求所带的数据，一般在POST、PUT等方法中使用。
2. 响应报文（Response Message）：
   - 状态行（Status Line）：包括HTTP版本、状态码和对应的状态消息。
   - 响应头部（Response Header）：包括响应的相关信息，如服务器类型、内容类型、响应时间等。
   - 空行（Blank Line）：响应头部与响应主体之间需要一个空行来分隔。
   - 响应主体（Response Body）：可选字段，包含响应的数据，一般在GET、POST等方法中返回。



# 12、什么是MVVM

模型（Model）指的是后端传递的数据。视图(View)指的是所看到的页面。视图模型(ViewModel)是mvvm模式的核心，它是连接view和model的桥梁。它有两个方向：一是将模型（Model）转化成视图(View)，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。二是将视图(View)转化成模型(Model)，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。这两个方向都实现的，我们称之为数据的双向绑定。

# 13、 请求头的请求方式

Content-Type是HTTP请求头中的一个字段，用于指定请求或响应中包含的实体主体的媒体类型。

在请求中，Content-Type用于告知服务器请求正文的媒体类型。常见的Content-Type值有：

- application/json：用于指定请求正文为JSON格式
- application/x-www-form-urlencoded：用于指定请求正文为表单数据形式
- multipart/form-data：用于指定请求正文为多部分表单数据形式（通常用于文件上传）
- text/plain：用于指定请求正文为纯文本形式
- application/xml：用于指定请求正文为XML格式

在响应中，Content-Type用于指定响应正文的媒体类型。常见的Content-Type值有：

- text/html：用于指定响应正文为HTML格式
- application/json：用于指定响应正文为JSON格式
- image/jpeg：用于指定响应正文为JPEG图片格式
- application/pdf：用于指定响应正文为PDF文档格式

# 14、vue双向绑定流程

1、实现一个[监听器](https://so.csdn.net/so/search?q=监听器&spm=1001.2101.3001.7020) `Observer` ，用来劫持并监听所有属性，如果属性发生变化，就通知订阅者；

2、实现一个订阅器 `Dep`，用来收集订阅者，对监听器 `Observer` 和 订阅者 `Watcher` 进行统一管理；

3、实现一个订阅者 `Watcher`，可以收到属性的变化通知并执行相应的方法，从而更新视图；

4、实现一个解析器 `Compile`，可以解析每个节点的相关指令，对模板数据和订阅器进行初始化。

# 15、vue生命周期

  创建前后：

beforeCreate 阶段：初始化数据还未开始，也就是说不能访问到data、computed、watch、methods上的方法和数据。
created 阶段：vue 实例的数据 data 有了， 渲染得节点还未挂载到 DOM，所以不能访问到 $el属性。（vue的实例挂载元素el）
 挂载前后：

在 beforeMount 阶段：Vue开始解析模板，生成虚拟DOM存在内存中，还没有把虚拟DOM转换成真实DOM，插入页面中。所以网页不能显示解析好的内容。
在 mounted 阶段：vue 实例挂载完后,将内存中的虚拟DOM转为真实DOM，真实DOM插入页面   （一般在这个阶段进行：开启定时器，发送网络请求，订阅消息，绑定自定义事件）
更新前后：

在beforeUpdate阶段：响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 DOM 还没有被渲染（数据是新的，但页面是旧的，页面和数据没保持同步呢）。
在updated阶段：更新完毕
销毁先后：

 在beforeDestory阶段：这个阶段一般进行关闭定时器，取消订阅消息，解绑自定义事件
在destoryed阶段：Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。

# 16、前后端数据的请求方式

1. HTTP请求：前端通过使用HTTP协议向后端发送请求，后端处理请求并返回相应的数据。常见的HTTP请求方式包括：
   - GET：用于获取数据，将数据放在URL的查询参数中。
   - POST：用于提交数据，将数据放在请求正文中。
   - PUT：用于更新数据，将数据放在请求正文中，通常会指定待更新数据的唯一标识符。
   - DELETE：用于删除数据，将待删除数据的唯一标识符放在URL中。
2. AJAX：AJAX是通过JavaScript异步发送HTTP请求的技术。前端使用XMLHttpRequest对象或Fetch API发起HTTP请求，而不需要刷新整个页面。通过AJAX，前端可以异步获取数据并动态更新网页内容。
3. WebSocket：WebSocket是一种持久化的通信协议，它建立在HTTP基础上，实现了双向通信。前端通过WebSocket与后端建立连接，并可在连接保持的情况下发送和接收数据。WebSocket适用于需要实时更新数据的应用，如聊天应用、实时通知等。

# 17、动态路由

定义路由表: 首先，在Vue Router的配置中定义路由表，包括需要动态传递的参数。可以使用冒号(:)来定义动态参数。例如：
const routes = [
  { path: '/user/:id', component: UserProfile }
]创建组件: 根据需要，创建对应的组件，用于显示根据动态参数加载的内容。例如，在上述示例中，我们可以创建一个名为UserProfile的组件。
// UserProfile.vue

<template>
  <div>
    <h1>User Profile</h1>
    <p>User ID: {{ userId }}</p >
  </div>
</template>


<script>
export default {
  data() {
    return {
      userId: null
    }
  },
  mounted() {
    this.userId = this.$route.params.id;
    // 根据userId加载对应用户的信息
  }
}
</script>使用路由参数: 在需要使用动态路由的地方，使用路由的名称和要传递的参数来构建动态链接。使用<router-link>来生成链接。例如，在其他组件中，可以这样使用动态路由链接：

<router-link :to="'/user/' + user.id">View Profile</router-link>监听路由变化: 如果需要在动态路由参数发生变化时执行某些操作（例如重新加载数据），可以使用Vue Router提供的导航守卫功能来监听路由的变化。导航守卫可以在路由切换前、切换后或任意导航触发时执行相应的逻辑。详情请参考Vue Router的导航守卫文档。

# 18、vue3.0响应原理

Vue 3.0的响应式原理通过基于Proxy的代理对象和依赖追踪来实现。Proxy在拦截对代理对象的访问和修改时，实现了对依赖的追踪和通知。这种基于Proxy的响应式系统在性能和功能方面有着明显的提升，使得Vue 3.0的响应式能力更加灵活和高效。

# 19、$el和v-el

在Vue.js中，`$el`和`v-el`都与操作DOM元素相关，但用法和作用略有区别。

1. `$el`：

   - `$el`是Vue组件实例的一个属性，用于访问实例所关联的根DOM元素。
   - 在组件实例化之后，可以通过`this.$el`来访问组件的根DOM元素。
   - 通过`$el`可以获取该组件生成的HTML元素，也可以操作DOM元素的属性和方法。

   例如，可以通过`this.$el.style`来访问组件根元素的样式，或者通过`this.$el.querySelector(selector)`来选择组件根元素中的子元素。

   ```
   export default {
     mounted() {
       console.log(this.$el) // 访问组件的根DOM元素
       console.log(this.$el.style) // 访问根DOM元素的样式
       console.log(this.$el.querySelector('.child-element')) // 选择根DOM元素中的子元素
     }
   }
   ```

   

   注意，使用`$el`直接操作DOM元素可能会违反Vue的响应式规则，因此在大多数情况下，推荐使用Vue的数据驱动方式来操作DOM。

2. `v-el`（已弃用）：

   - `v-el`是Vue.js 2.x版本中的一个自定义指令，用于在组件实例中注册一个DOM元素的引用。
   - `v-el`指令指定一个名称，该名称将与一个引用元素关联。组件实例可以使用这个名称来访问引用的DOM元素。
   - 但是，从Vue.js 2.0起，`v-el`指令已经被废弃，不再建议使用，并被新的`ref`属性代替。因此，不推荐在Vue.js 2.x中使用`v-el`指令。

   例如，在Vue.js 1.x版本中，可以使用`v-el`指令为DOM元素注册引用，并在组件中使用该引用：

   ```
   <template>
     <div>
       <button v-el:myButton @click="handleClick">Click me</button>
     </div>
   </template>
   
   <script>
   export default {
     methods: {
       handleClick() {
         console.log(this.$els.myButton) // 通过引用访问DOM元素
       }
     }
   }
   </script>
   ```

   

   在Vue.js 2.x版本中，不再推荐使用`v-el`指令，而是推荐使用`ref`属性来获取DOM元素的引用。

总结：`$el`是Vue组件实例的一个属性，用于访问组件的根DOM元素；而`v-el`是Vue.js 1.x版本中的指令，用于在组件中注册DOM元素的引用，但在Vue.js 2.x版本中已被废弃，不推荐使用。在Vue.js 2.x中，应该使用`ref`属性来获取DOM元素的引用。

# 20、ref

> 1、ref 加在普通的元素上，用 this.$refs.name 获取到的是dom元素
>
> 2、ref 加在子组件上，用 this.$refs.name 获取到的是组件实例，可以使用组件的所有方法。
>
> 注意：
>
> ref 需要在dom 渲染完成后才会有，在使用的时候确保dom已经渲染完成。
>
> 比如在生命周期 mounted(){ } 钩子中调用，或者在 this.$nextTick(()=>{ }) 中调用。

# 21、SSR

SSR（Server-Side Rendering，服务端渲染）是一种在服务器端生成HTML页面的技术，与传统的前端渲染（客户端渲染）不同。在传统的前端渲染中，浏览器会下载初始的HTML页面，然后通过执行JavaScript来动态生成并填充页面内容。

SSR的优势包括：

1. 更好的SEO（Search Engine Optimization，搜索引擎优化）：搜索引擎能够直接读取到渲染好的HTML内容，有利于网页的索引和排名。
2. 更快的首屏加载速度：客户端不需要再等待JavaScript代码的执行，直接展示已渲染好的HTML页面，提供更好的用户体验。
3. 更好的可访问性：对于某些搜索引擎爬虫、低端设备或不支持JavaScript的浏览器，SSR页面能够提供基本的可访问性。
4. 渐进增强：通过在服务器端生成HTML页面，可以确保即使在客户端JavaScript出现问题时，用户仍然能够访问到基本的页面内容。

# 22、混入

在Vue.js中，混入（Mixins）是一种重用组件逻辑的方式。通过混入，我们可以将一些常见的组件选项（如数据、生命周期钩子、方法等）提取出来，并混入到多个组件中。

混入可以用于以下情况：

1. 多个组件需要共享相同的逻辑或功能。
2. 想要在组件中重用一些通用的代码。
3. 编写可复用的逻辑，以供其他开发者使用。

通过混入，我们可以将一些常见的逻辑提取成一个混入对象，然后将其混入到需要共享该逻辑的组件中。

混入的使用方式如下：

```js
// 定义混入对象
var myMixin = {
  data() {
    return {
      message: 'Hello Mixin!'
    }
  },
  methods: {
    greet() {
      console.log(this.message);
    }
  }
}

// 在组件中使用混入
Vue.component('my-component', {
  mixins: [myMixin],
  created() {
    this.greet(); // 可以调用混入对象中的方法
  }
})

// 创建Vue实例
new Vue({
  el: '#app',
  template: '<my-component></my-component>'
})
```

在上面的例子中，我们定义了一个名为 `myMixin` 的混入对象，该对象包含一个 `data` 属性 `message` 和一个方法 `greet`。然后，我们将 `myMixin` 混入到一个组件中，并在该组件的 `created` 生命周期钩子中调用 `greet` 方法。

通过混入，组件可以获得 `myMixin` 中定义的 `message` 数据和 `greet` 方法，从而实现代码的复用。

需要注意的是，如果混入对象和组件本身有相同名称的选项，则组件本身的选项会覆盖混入对象的选项。另外，混入会按照从右向左的顺序进行合并，这意味着后面混入的对象会覆盖前面的对象。

总的来说，混入提供了一种在多个组件之间共享可重用代码的方式，它可以提取组件的通用逻辑，从而实现代码的复用和组合。

# 23、后端操作数据库怎么操作

后端操作数据库的方式和具体步骤可能会因为开发语言和数据库类型的不同而有所区别，以下是一个一般的操作流程：

1. 连接数据库：
   首先需要使用适当的数据库驱动程序来连接到数据库服务器。根据后端语言和所使用的数据库类型，可能需要提供数据库服务器的连接信息，如主机名、端口号、用户名、密码等。
2. 执行查询或操作：
   一旦成功连接到数据库，就可以使用相关的库或框架来执行各种查询和操作。常见的数据库操作有创建表、插入数据、更新数据、删除数据、查询数据等。
3. 处理结果：
   对于读取操作（如查询数据），可以从数据库中获取结果，并对结果进行处理和解析，以便在后端进行进一步操作或返回给前端。
4. 关闭数据库连接：
   在不再需要访问数据库时，应该关闭数据库连接，以释放资源并保持数据库的稳定性。

需要注意的是，通过后端操作数据库时，必须进行适当的数据验证和安全防护措施，以防止潜在的安全风险，如SQL注入等。此外，了解所使用数据库的文档和特性，以及掌握适当的查询语言和技术，对于高效地操作数据库也是非常重要的。

总的来说，后端操作数据库的过程包括连接数据库、执行查询或操作、处理结果和关闭数据库连接。具体的代码实现会因为开发语言和数据库类型的不同而有所差异。

# 24、都用什么数据库

在后端开发中，可以使用多种不同类型的数据库，选择适合自己项目需求的数据库。以下是一些常见的数据库类型：

1. 关系型数据库（RDBMS）：
   - MySQL：一种流行的开源关系型数据库管理系统，用于处理结构化数据。
   - PostgreSQL：一个强大且高度可扩展的对象关系型数据库系统，支持复杂的数据类型和功能。
   - Oracle Database：一种商业关系型数据库，具有强大的功能和高性能。
   - Microsoft SQL Server：一种由Microsoft提供的商业关系型数据库，适用于Windows环境。
2. 非关系型数据库（NoSQL）：
   - MongoDB：一种面向文档的数据库，适合存储非结构化和半结构化数据。
   - Redis：一种内存键值存储数据库，用于缓存、会话存储和消息队列等场景。
   - Cassandra：一种高度可扩展的分布式NoSQL数据库，用于处理大规模的结构化和非结构化数据。
   - Elasticsearch：一种用于全文搜索和分析的分布式NoSQL数据库。
3. 图数据库：
   - Neo4j：一种高性能的图数据库，用于存储和处理图形数据。
4. 时间序列数据库：
   - InfluxDB：一种专门用于处理时间序列数据的开源数据库，常用于监控和IoT应用。
5. 内存数据库：
   - Apache Ignite：一种分布式内存数据库，用于缓存和处理大规模的数据集。

这只是一小部分可用的数据库类型，选择适合自己项目需求的数据库需要综合考虑因素，如数据结构、访问模式、性能要求、可伸缩性、安全性和成本等。

另外，有些项目可能需要同时使用多种数据库类型，例如使用关系型数据库存储事务性数据，而使用非关系型数据库存储大量的日志数据。最终的选择应该基于具体的项目需求和技术考量。

# 25、组件间通信

在Vue.js中，组件间通信是一个重要的主题，可以通过以下几种方式实现组件间的数据传递和通信：

1. 父子组件通信：
   - Props：父组件通过props向子组件传递数据，子组件通过props接收父组件传递的数据。
   - Emit：子组件通过emit：子组件通过emit方法触发自定义事件，父组件通过v-on监听子组件的自定义事件并处理相应的逻辑。
2. 兄弟组件通信：
   - Event Bus：使用一个独立的Vue实例作为事件中心，兄弟组件通过该实例进行事件的触发和监听。
   - Vuex：Vue的状态管理模式，兄弟组件可以通过共享的store来实现数据共享和通信。
3. 跨级组件通信：
   - Provide / Inject：祖先组件通过provide提供数据，后代组件通过inject注入数据，实现跨级组件之间的通信。
4. 任意组件通信：
   - Global Event Bus：使用一个全局的Vue实例作为事件中心，任何组件都可以通过该实例进行事件的触发和监听。
   - Local Storage / Session Storage：使用浏览器本地存储来实现不同组件之间的数据共享。

除了以上提到的方式，还可以使用第三方库或插件来实现组件间的通信，如PubSub.js、VueX EventBus等。

需要根据具体的项目需求和场景来选择合适的通信方式。同时，需要注意避免过多地使用全局通信，以维护代码的可维护性和可测试性。如果组件之间的通信变得过于复杂，可能需要重新考虑组件的结构和架构，以减少耦合性和提高可组合性。

# 26、vue如何扩展组件（混入方式扩展）

在Vue.js中，可以使用混入（Mixins）方式扩展组件的功能。混入允许我们将一些常见的组件选项（如数据、生命周期钩子、方法等）提取出来并混入到多个组件中，以实现代码的复用和扩展。

以下是使用混入方式扩展组件的步骤：

1. 创建混入对象：
   首先，创建一个混入对象，该对象包含你想要扩展的组件选项。

   ```js
   var myMixin = {
     data() {
       return {
         message: 'Hello, I am a mixin!'
       };
     },
     methods: {
       greet() {
         console.log(this.message);
       }
     }
   };
   ```

   2.在组件中使用混入：
   在需要扩展的组件中，使用`mixins`选项将混入对象与该组件关联。

   ```js
   Vue.component('my-component', {
     mixins: [myMixin],
     created() {
       this.greet(); // 调用混入对象中的方法
     }
   });
   ```

   在上述示例中，我们创建了一个名为`myMixin`的混入对象，它包含了`data`属性和`greet`方法。然后我们在`my-component`组件中使用`mixins`选项将`myMixin`混入到该组件，从而继承了混入对象中的数据和方法。

   需要注意的是，如果混入对象和组件本身具有相同名称的选项，组件本身的选项会覆盖混入对象的选项。此外，如果多个混入对象具有相同名称的选项，则它们将按照混入声明的顺序进行合并。

   通过混入方式，我们可以将通用的逻辑提取成混入对象，并在需要的组件中进行复用和扩展，从而减少代码冗余并提高代码的可维护性。

   需要注意的是，滥用混入可能导致代码的可读性和维护性降低，因此在使用混入时应谨慎选择合适的时机和方式。

   # 27、封装组件的注意点

   封装组件是在Vue.js开发中非常重要的一部分，以下是一些封装组件时需要注意的事项：

   1. 单一职责原则：
      每个组件应该尽量遵循单一职责原则，即一个组件应该只负责一项特定的功能或UI展示。这样可以保持组件的可复用性和可维护性，并且更易于测试和理解。
   2. props验证：
      对于从父组件传递给子组件的props，应该进行合适的验证。通过使用prop验证来确保传入的数据满足预期的类型、格式和限制条件。这可以增加组件的健壮性并减少错误。
   3. 插槽使用：
      使用Vue.js的插槽（slots）来允许在组件中插入内容，增加组件的灵活性和可扩展性。合理使用默认插槽、具名插槽和作用域插槽，以满足各种使用场景。
   4. 内部状态封装：
      组件应该尽量封装自己的内部状态，通过data选项来管理组件的内部数据。避免直接操作父组件的数据，以减少组件之间的耦合。
   5. 事件派发与监听：
      使用自定义事件（event）在组件内部进行通信，可以通过$emit方法派发事件，在父组件通过v-on监听并处理相应的逻辑。合理使用事件进行组件间的解耦和通信。
   6. UI组件与业务逻辑分离：
      将组件的UI展示与业务逻辑分离开来，这样可以使组件更加可复用和灵活。业务逻辑应该放在组件之外，通过业务逻辑组合和组合式API来驱动组件。这样可以有效降低代码耦合性和提高组件的可维护性。
   7. 文档和示例：
      封装好的组件应该提供详细的文档和示例，方便其他开发者使用和理解。文档应该包括组件的用法、props的说明、事件的使用方式以及可能的插槽等。
   8. 性能优化：
      对于复杂的组件或对性能要求较高的场景，需要注意进行性能优化，如避免不必要的渲染、使用v-if和v-show进行条件渲染、合理使用computed属性等。

   以上是封装组件时需要注意的一些重点。遵循这些原则和注意事项，可以提高组件的可复用性、可维护性和性能，并且提升开发效率。

   # 28、单表的项目设计

   针对单表的项目设计，你可以考虑以下几个方面来规划和设计数据库表结构：

   1. 定义表的用途和功能：明确每个数据库表的用途和功能，确保表的设计符合项目需求，并尽量使每个表负责单一的实体或概念。
   2. 表的字段设计：根据表的用途和功能，定义合适的字段，确保每个字段都有明确的含义和数据类型，充分考虑数据的完整性和准确性。
   3. 主键设计：为每个表选择一个主键，用于唯一标识每条记录。常见的选择包括自增长字段、GUID、业务相关的唯一标识等。
   4. 关联和外键设计：确定不同表之间的关联关系，并使用外键来维护这些关联关系。外键可用于确保数据一致性和引用完整性。
   5. 索引设计：根据查询需求和数据访问模式，设计适当的索引来提高查询性能。索引可以加速数据的检索，但也会增加写操作的开销，因此需要权衡利弊。
   6. 数据库范式化与反范式化：根据具体的需求，决定是采用范式化设计还是反范式化设计。范式化可以提高数据的一致性和规范性，但可能导致查询复杂性和性能问题。反范式化可以提高查询性能，但可能导致数据冗余和更新操作的复杂性。
   7. 数据类型选择：选择合适的数据类型来存储数据，以节约存储空间并提高查询效率。根据数据的性质和大小，选择适当的整数类型、字符类型、日期时间类型等。
   8. 表的命名和命名规范：为表、字段、约束等命名时，遵循一致的命名规范和最佳实践，以便于项目成员理解和维护。
   9. 安全性和权限控制：考虑数据的安全性，并根据需求设置合适的权限控制，确保只有授权用户能够访问和修改数据。
   10. 性能和扩展性考虑：在设计的过程中，要考虑到数据量的增长和访问的并发性，设计表结构和索引以支持高性能和扩展性。

   这些是设计单表项目时需要考虑的一些关键点。当然，具体的设计还需要根据项目的需求和复杂性进行调整和优化。设计良好的数据库表结构可以提高数据的管理和操作效率，有助于项目的开发和维护工作。

   # 29、router和route的区别

   在Vue.js中，Router（路由器）和Route（路由）是两个相关但不同的概念：

   1. Router（路由器）：
      Router（也称为路由器）是Vue.js的核心插件之一，它负责管理应用程序的路由功能。在Vue Router中，我们可以创建一个Router实例，用于管理应用程序的路由规则、导航和路由状态。Router负责定义路由规则、匹配URL并导航到对应的组件，以及管理浏览器历史记录。它允许我们在应用程序中实现页面之间的导航，并通过处理URL来控制页面的切换和展示。
   2. Route（路由）：
      Route（也称为路由）是指定义和描述单个路由的对象。在Vue Router中，每个定义的路由规则都是一个Route对象。一个Route对象包含了路由的路径、组件、参数、元信息等信息。通过路由规则的配置，我们可以定义不同路径对应的组件，以及传递参数给组件或控制组件的显示和行为。

   简单说，Router是Vue Router的实例，负责整个应用程序的路由管理；而Route是单个路由的定义和描述，包含了路径、组件等路由信息。

   在Vue Router中，我们通过创建Router实例并定义一系列的Route规则来管理路由。当用户导航到特定的URL时，Router会根据定义的规则匹配对应的Route，然后根据Route的信息来渲染相应的组件。

   总结起来，Router是整个应用程序的路由管理器，而Route是单个路由的对象描述。通过Router和Route的结合使用，我们可以实现Vue.js应用程序的路由功能。

   
