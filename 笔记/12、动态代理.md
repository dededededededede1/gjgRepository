#### 代理的意义：

就是想办法解析出被代理对象中实现的方法以及implements的接口，然后用代理去调用这些方法。并由代理完成这些代理业务操作

### 静态代理

1。静态代理的接口只能服务于一种类型的对象，如果要代理的方法有很多，则要为每一个方法设置一个代理，静态代理在程序规模稍大一点的时候，就会显得复杂得多。

2。如果接口新增了一个方法，处理代理类需要实现这个方法之外，所有被代理类也要改，增加了代码得维护成本。

### 动态代理

不需要去定义代理类，会自动生成一个代理对象，只需要在生成代理对象的时候声明代理逻辑就行。

动态代理的源码会在程序运行时由JVM、ASM(字节码文件)动态生成，***代理类与被代理类的关系在程序运行时才能确定***。

### 通过java提供的指定方式生成代理对象，此时生成的代理对象需要明确的三个内容(被代理对象一般是*service的实现类*)：

1.**被代理对象是通过哪个类加载器进行加载的**，由于不同类的类加载器不同(系统类、平台类、启动类),所以要找到被代理对象的类加载器。***(因为要保证通过同一个类加载器进行加载)***

通过被代理类的Class对象调用getClassLoader()，即可获取到这个类加载器(**被代理对象.getClass().getClassLoader()**)

2.被代理类实现了哪些接口，要获取到接口的Class对象，如果实现了多个对象，需要传递所有接口的Class对象组成的class数组。***(因为动态生成呃代理对象要明确自身的行为)***

通过被代理类的Class对象调用getInterfaces(),即可获取到被代理类所实现接口的Class数组。(**接口实现类.getClass().getInterfaces()**)

3.具体的代理逻辑是什么，哪些方法需要代理，哪些不需要

通过传递定义好的动态代理逻辑执行器对象，并且传递被代理对象作为参数。

步骤：1、获取这个类(被代理对象)的类加载器；2、获取这个类实现的所有接口的类加载器；3、创建InvocationHandler对象；4.、将这三个参数传入Proxy.newProxyInstance(1，2，3)中用接口接收。

第四步用接口的引用接收之后，调用的就是接口中的方法，也就是代理对象和被代理对象共有的方法。当接口引用执行方法时，**会优先进入invoke方法中进行处理**。

### AOP与动态代理的区别

* JDK动态代理是**基于接口的代理方式**，其实现原理是让代理对象与原生对象(被代理对象)**实现相同的接口**，并且在代理对象内部**维护一个原生对象的引用**。这样一来，不需要加强的方法，就可以通过原生对象的引用直接返回。需要加强的方法可以在原生对象方法执行前后做相应的处理。
* CGLIB动态代理是**基于继承的代理方式**，其实现原理也是在代理对象内部**维护一个原生对象的引用**，不同的是此方式生成的代理对象是原生对象的子类。因此由于**final类中的方法、private方法、final方法不能被继承**，因此这些方法都无法使用CGLIB进行增强。

#### Spring相关特性

* Spring IOC中存放的Bean默认是单例的
* Spring IOC进行依赖注入时，只有需要被AOP加强的Bean才会注入代理对象，否则注入原生对象
* Spring MVC中的AOP底层实现默认是JDK动态代理，只有被代理的类没有实现接口时才会使用CGLIB代理。
* Spring Boot中的AOP的底层实现默认是CGLIB。
* Spring中的一些注解（@Async@Retry@Transaction）都属于AOP的一种
  需要被AOP增强的方法，必须由代理对象直接调用才能生效（内部方法调用不生效）。
* 如果一个被spring管理的类使用了AOP，那么在IOC容器中维护的就是该类的代理对象。如果采用的是JDK动态代理，那么就只能通过接口的方式进行注入。通过实现类进行注入时将会提示类转换异常。

Java动态代理是一种设计模式，它允许在运行时创建代理对象，通过代理对象实现对目标对象的方法调用进行控制。动态代理的实现原理主要依赖于Java的反射和接口机制。Java提供了java.lang.reflect.Proxy类和java.lang.reflect.InvocationHandler接口来实现动态代理。

以下是动态代理的实现原理：

1. 定义一个接口：要使用Java动态代理，首先需要定义一个接口。代理类和目标类都会实现这个接口。

```
public interface Subject {
    void doSomething();
}
```

1. 创建目标类：实现上述定义的接口。

```java
public class RealSubject implements Subject {
    @Override
    public void doSomething() {
        System.out.println("RealSubject is doing something.");
    }
}
```

1. 创建InvocationHandler：实现InvocationHandler接口，它负责处理对代理对象方法的调用。在invoke方法中，我们可以在调用目标对象的方法前后添加自己的逻辑。

```java
public class MyInvocationHandler implements InvocationHandler {
    private Object target;

    public MyInvocationHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("Before method call.");
        Object result = method.invoke(target, args);
        System.out.println("After method call.");
        return result;
    }
}
```

1. 创建动态代理对象：使用java.lang.reflect.Proxy类的newProxyInstance方法来创建代理对象。这个方法接收三个参数：类加载器（用于加载代理类）、接口数组（代理类需要实现的接口）和InvocationHandler实例。

```java
Subject realSubject = new RealSubject();
InvocationHandler handler = new MyInvocationHandler(realSubject);
Subject proxySubject = (Subject) Proxy.newProxyInstance(
        realSubject.getClass().getClassLoader(),
        realSubject.getClass().getInterfaces(),
        handler);
```

1. 调用代理对象的方法：通过代理对象调用方法，实际上调用的是InvocationHandler中的invoke方法。

```
proxySubject.doSomething();
```

运行以上代码，输出结果如下：

```
Before method call.
RealSubject is doing something.
After method call.
```

总结一下，Java动态代理的实现原理主要包括以下几个步骤：

1. 定义一个接口。
2. 创建目标类实现该接口。
3. 创建实现InvocationHandler接口的类，并重写invoke方法。
4. 使用Proxy.newProxyInstance方法创建代理对象。
5. 通过代理对象调用目标对象的方法。

这样，我们可以在不修改目标类代码的情况下，通过动态代理实现对目标对象方法的拦截和增强。
