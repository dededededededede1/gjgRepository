## 接口Interface

接口中的成员变量默认都是public、static、final类型的，必须被显式初始化

接口中的方法默认都是public、abstract类型的。

***接口中只能包含public、static、final类型的成员变量和public、abstract类型的成员方法。***

接口没有构造方法，不能被实例化，**在接口中定义构造方法是非法的**。

一个接口**不能实现另一个接口**，但它可以**继承多个其他接口。**
interface C extends A, B{} // A和B都是接口

当类实现某个接口时，它必须实现接口中所有的抽象方法，否则这个类必须被定义为抽象类。

接口中没有方法体

## 访问控制修饰符


四种访问级别：public、protected、默认、private
private只能在同一个类中访问
默认，只能在同一个类，同一个包中访问
protected，可以在统一各类，同一个包，子类(子类可以不在同一个包中)访问
public，不限制访问
类可用修饰符： abstract、public、final
构造方法：public、protected、private
局部变量：仅仅final

## abstract修饰符

抽象类中可以没有抽象方法，但包含了抽象方法的类必须被定义为抽象类。

没有抽象构造方法，没有抽象静态方法。 static 和 abstract不能连用

抽象类中可以有非抽象的构造方法，创建子类的实例时可能会调用这些构造方法。

抽象类及抽象方法不能被final修饰符修饰。final和abstract 不能连用，同样private和abstract不能连用。

抽象类不能被实例化。因为抽象类可能含有没有方法体的抽象方法


## final修饰符

final具有不可改变的含义，它可以修饰非抽象类，非抽象成员方法和变量

用final修饰的类不能被继承，没有子类。

用final修饰的方法不能被子类的方法覆盖。

用final修饰的变量表示常量，只能被赋一次值，必须被显式初始化。

private修饰的方法默认为是final方法，因而不能被子类的方法覆盖。


## static修饰符

静态变量在内存中只有一个拷贝，在类的所有实例中共享。

在静态方法中不能直接访问实例方法和实例变量。

在静态方法中不能使用this和super关键字。

静态方法不能被abstract修饰

静态方法和静态变量都可以通过类名直接被访问。

当类被加载时，静态代码块只被执行一次。类中不同的静态代码块按它们在类中出现的顺序被依次执行
public static void main(String args[]) {} 程序入口方法，可以被final修饰。


## super关键字

在类的构造方法中，通过super语句调用这个类的父类的构造方法。
在构造方法中，super语句必须作为构造方法的第一条语句。

在子类中访问父类的被屏蔽的方法和属性

只能在构造方法或实例方法内使用super关键字。 super关键字与类的特定实例相关


## 方法覆盖（方法重写）

方法的参数签名和返回值类型必须相同，访问控制修饰符可以不同，但是子类方法不能缩小父类方法的访问权限。

子类方法抛出的异常必须和父类方法抛出的异常相同，或者是父类方法抛出的异常类的子类。

父类的静态方法是不能被子类覆盖为非静态方法。
父类的非静态方法不能被子类覆盖为静态方法。

子类可以定义与父类的静态方法同名的静态方法，以便在子类中隐藏父类的静态方法。区别：运行时，JVM把静态方法和所属的类绑定，而把实例方法和所属的实例绑定。

父类的私有方法不能被覆盖

父类的非抽象方法可以被覆盖为抽象方法


## 方法重（chong）载

在一个类中不允许两个方法名相同，并且参数签名也完全相同的方法。

类的同一种功能，可能有多种实现，到底采用哪种实现方式，取决于调用者给定的参数。

对于类的方法（包括从父类中继承的方法），如果有两个方法的方法名相同，但参数不一致，那么可以说，一个方法是另一个方法的重载方法。
多态

对于一个引用类型的变量，Java编译器按照它声明的类型来处理。
Base base = new Sub();
base.subMethod(); // 编译出错，Base基类，Sub子类，编译器认为base是Base类型的引用变量，Base类没有subMethod()方法。这样子，就必须使用强制转换。(Sub)(base).subMethod();

对于一个引用类型的变量，运行时JVM按照它实际引用的对象来处理。
Base base = new Base();
Sub sub = (Sub)base; // 编译通过，但是运行时抛出ClassCastException
在运行时，子类的引用类型变量可以转换为父类的引用类型，而相反的过程却不可以。
假定可以，即上边两行代码运行正常，那么sub.subMethod(); 执行时，JVM将找不到subMethod。sub实际引用的是Base类的实例。

在运行时环境中，通过引用类型变量来访问所引用对象的方法和属性时，JVM采用以下的绑定规则。
①实例方法与引用变量实际引用的对象的方法绑定，即动态绑定。
②静态方法与引用变量所声明的类型的方法绑定，即静态绑定。 编译阶段即绑定完成。
③成员变量(静态变量和实例变量) 与引用类型所声明的类型的成员变量绑定。静态绑定。
