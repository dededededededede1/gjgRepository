## 事物的四大特性ACID

1. 原子性（Atomicity）：事务是一个不可分割的单位，要么全部执行成功，要么全部回滚到初始状态。如果事务中的任何一个操作失败，那么整个事务将被回滚，数据库状态将回到事务开始之前的状态。
2. 一致性（Consistency）：事务执行前后，数据库从一个一致性状态转变为另一个一致性状态。这意味着事务必须满足所有预定义的规则和约束，以保持数据的完整性。
3. 隔离性（Isolation）：每个事务都应该被隔离开来，互不干扰。事务的并发执行可能导致数据不一致的问题，因此隔离性确保每个事务在执行期间都能够独立地访问和修改数据，而不受其他事务的干扰。
4. 持久性（Durability）：一旦事务成功提交，其结果应该永久保存在数据库中，并且对于任何系统故障或崩溃，系统应该能够恢复到提交后的状态。持久性保证了数据的持久性，即使在系统故障的情况下也能够恢复。

## 事物的四个隔离级别

脏读、不可重复读、幻读，网上介绍这几个概念的博文很多。天下博文一大抄，都没有说清楚不可重复读和幻读的区别，只有一篇文章略微提到了一点，这里结合我的理解说一下。 **其实这三种现象都是并发读写导致的。**

#### “脏读”

指读到了未提交的数据，然后基于这个数据做了一些事情，结果做完发现数据被回滚了。**可以理解为领导还没下达正式任务你就凭着自己的揣摩开始干活，结果活干完了，任务的内容被改了。**

#### “不可重复读”

好一点，读到的是已提交的数据，比如某个读事务持续时间比较长，期间多次读取某个元组，每次读到的都是被别人改过并已提交的不同数据。可以理解为在执行任务的过程中，领导的指令一直在变。但好歹是正式下达的指令。

#### “幻读”

是指读的过程中，某些元组被增加或删除，这样进行一些集合操作，比如算总数，平均值等等，就会每次算出不一样的数。 所以“不可重复读”和“幻读”都是读的过程中数据前后不一致，只是前者侧重于修改，后者侧重于增删。 个人认为，严格来讲“幻读”可以被称为“不可重复读”的一种特殊情况，没错的。但是从数据库管理的角度来看二者是有区别的。解决“不可重复读”只要加行级锁就可以了。而解决“幻读”则需要加表级锁，或者采用其他更复杂的技术，总之代价要大许多。这是搞数据库的那帮家伙非要把这两者区分开的动机吧。

| Mysql隔离级别 | 脏读 | 不可重复读 | 幻读 |
| :-----------: | :--: | :--------: | :--: |
|   读未提交   |  √  |     √     |  √  |
|   读已提交   |  ×  |     √     |  √  |
|   可重复读   |  ×  |     ×     |  √  |
|   可串行化   |  ×  |     ×     |  ×  |

**禁止写时读，避免了“脏读”，对应隔离级别read committed。** **禁止读时写，避免了“不可重复读”，对应隔离级别repeatable read。** **而为了避免“幻读”，干脆把整个表给锁住了，只能是serialize了。** 隔离级别越高，并行度越低，付出的代价越大。顺便说一下，phantom这个词是幻影，幽灵的意思，跟“幻读”的现象没有直接关系。很多文章说遇到“幻读”就像出现幻觉一样，个人以为十分牵强。“幻读”就是软件工程中一个很普通的问题，是人类思虑不周全的结果。老外工程师通过禁止读的时候修改解决了“不可重复读”的问题，本以为万事大吉了，谁知又出现了增加导致的不一致，不由感慨：我X真是个phantom。用中国话说，就是真TM见鬼了。国内翻译成了“幻读”，搞得很神秘，逼格很高的样子。
